

----Begin:Tokens--------
// Be careful when lexing because tokens are greedy. If you have 3 tokens /fro/ /from/ /frome/,
// the string "from frome" becomes [fro, m, fro, me].
// the (?![a-zA-Z0-9_]) means to look ahead to make sure no other word/letters are there.
// important, otherwise if you have tokens "the" and "then", you'd need to order everything right, or "then" would lex into "the", "n"
TkBkgndsyn=/background(?![a-zA-Z0-9_])|bkgnd(?![a-zA-Z0-9_])|bg(?![a-zA-Z0-9_])/i
TkBkgndssyn=/backgrounds(?![a-zA-Z0-9_])|bkgnds(?![a-zA-Z0-9_])|bgs(?![a-zA-Z0-9_])/i
TkCardsyn=/card(?![a-zA-Z0-9_])|cd(?![a-zA-Z0-9_])/i
TkCardssyn=/cards(?![a-zA-Z0-9_])|cds(?![a-zA-Z0-9_])/i
TkBtnsyn=/button(?![a-zA-Z0-9_])|btn(?![a-zA-Z0-9_])/i
TkBtnssyn=/buttons(?![a-zA-Z0-9_])|btns(?![a-zA-Z0-9_])/i
TkFldsyn=/field(?![a-zA-Z0-9_])|fld(?![a-zA-Z0-9_])/i
TkFldssyn=/fields(?![a-zA-Z0-9_])|flds(?![a-zA-Z0-9_])/i
TkCharsyn=/characters(?![a-zA-Z0-9_])|character(?![a-zA-Z0-9_])|chars(?![a-zA-Z0-9_])|char(?![a-zA-Z0-9_])/i
TkCommandcharsyn=/commandchar(?![a-zA-Z0-9_])|cmdchar(?![a-zA-Z0-9_])/i
TkMsgsyn=/message(?![a-zA-Z0-9_])|msg(?![a-zA-Z0-9_])/i
TkPrevsyn=/previous(?![a-zA-Z0-9_])|prev(?![a-zA-Z0-9_])/i
TkOfOnly=/of(?![a-zA-Z0-9_])/
TkInOnly=/in(?![a-zA-Z0-9_])/
TkA=/a(?![a-zA-Z0-9_])/
TkProductname=new RegExp(cProductName + '(?![a-zA-Z0-9_])', 'i')
TkRequestEval=/\$\$RequestEval(?![a-zA-Z0-9_])/
TkRequestHandlerCall=/\$\$RequestHandlerCall(?![a-zA-Z0-9_])/
TkRequestUserFnCall=/\$\$RequestCustomFnCall(?![a-zA-Z0-9_])/

// two symbols
TkNotEqBasicStyle=/<>/
TkNotEqCStyle=/!=/
TkConcatDouble=/&&/
TkGreaterEqual=/>=/
TkLessEqual=/<=/

// one symbol
TkConcatSingle=/&/
TkPlus=/\+/
TkMinus=/-/
TkCaret=/\^/
TkMult=/\*/
TkDivide=/\//
TkGreater=/>/
TkLess=/</
TkComma=/,/
TkLParen=/\(/
TkRParen=/\)/
TkEquals=/==?/

// reserved words. use cannot create a variable with these names.
the=SAME
put=SAME
set=SAME
last=SAME
mid=SAME
middle=SAME
repeat=SAME
any=SAME
true=SAME
false=SAME
first=SAME
second=SAME
third=SAME
fourth=SAME
fifth=SAME
sixth=SAME
seventh=SAME
eigth=SAME
ninth=SAME
tenth=SAME
this=SAME
next=SAME
box=SAME
window=SAME
word=SAME
item=SAME
line=SAME
to=SAME
me=SAME
target=SAME
id=SAME
stack=SAME
before=SAME
after=SAME
into=SAME
plain=SAME
bold=SAME
italic=SAME
underline=SAME
outline=SAME
shadow=SAME
condense=SAME
extend=SAME
from=SAME
push=SAME
open=SAME
close=SAME
left=SAME
right=SAME
up=SAME
down=SAME
out=SAME
top=SAME
bottom=SAME
center=SAME
rect=SAME
select=SAME
text=SAME
shiftkey=SAME
optionkey=SAME
commandkey=SAME
add=SAME
answer=SAME
with=SAME
or=SAME
ask=SAME
password=SAME
beep=SAME
choose=SAME
tool=SAME
click=SAME
at=SAME
delete=SAME
disable=SAME
divide=SAME
by=SAME
drag=SAME
enable=SAME
get=SAME
go=SAME
hide=SAME
menubar=SAME
lock=SAME
screen=SAME
messages=SAME
error=SAME
dialogs=SAME
recent=SAME
multiply=SAME
reset=SAME
paint=SAME
printing=SAME
show=SAME
all=SAME
sort=SAME
ascending=SAME
descending=SAME
numeric=SAME
international=SAME
datetime=SAME
lines=SAME
items=SAME
subtract=SAME
unlock=SAME
visual=SAME
effect=SAME
wait=SAME
for=SAME
long=SAME
short=SAME
abbrev=SAME
abbr=SAME
abbreviated=SAME
length=SAME
result=SAME
paramcount=SAME
params=SAME
number=SAME
words=SAME
there=SAME
is=SAME
an=SAME
no=SAME
not=SAME
integer=SAME
point=SAME
logical=SAME
and=SAME
contains=SAME
within=SAME
div=SAME
mod=SAME

// space, literals
// possible to use 0|[1-9]\d+ to disallow 00123, I don't care right now.
TkNumber=/[0-9]+(\.[0-9]+)?/
TkContinuedLine=/\\\n/|||||static GROUP = ChvLexer.SKIPPED;static LINE_BREAKS = true
TkNewLine=/\n+/|||||static LINE_BREAKS = true
TkStringLiteral=/"[^"\n]*"/
TkWhiteSpace=/[ \t]+/|||||static GROUP = ChvLexer.SKIPPED

// should be last
TkIdentifier=/[a-zA-Z][0-9a-zA-Z_]*/
----End:Tokens--------



----Begin:Rules--------

//////////////////////////////////////////////////////// 

// there are several semi-keywords, like "transparent". You can use the term transparent with no parens like set the style to transparent,
// but also create a variable (put "abc" into transparent) with no problem. so is "transparent" a keyword or not?
// the product is very lenient -- you can even assign over functions (put "abc" into cos; answer cos && cos)
// note that if we made "transparent" et all a token, then it would be difficult to allow a variable named transparent. also, we'd have nearly 100 more tokens to deal with.
// let's use this approach:
//      certain terms are reserved keywords like "true", "up", "rect". defined as tokens, cannot be used as variable names at all.
//      certain terms are built-in properties/functions. "cos", "mouseloc". not defined as tokens. if you try 'put "abc" into cos' we check at runtime and error then.
//      certain terms are allowed as variable names and understood in some contexts. like "transparent" or "gray".
//      another benefit: user typos like "autoHilite2" don't create a mysterious syntax error, can have a better error message, "unknown property"

// note that in the product, nearly all functions can be used without parens. ("the sin of 4" == "sin(4)"). I don't like this, so I'm not implementing it.

// a bit of a space/time tradeoff.
// when we cram everything into one rule, slightly less space in memory taken as CST has fewer branches
// however, this also means slightly longer time in traversing as there are many conditionals to see which subrule is not null

///////////// Chunks and Prepositions

HOrdinal:=[ the ] { last | mid | middle | any | first | second | third | fourth | fifth | sixth | seventh | eigth | ninth | tenth }
HPosition:={this | TkPrevsyn | next | the TkPrevsyn | the next }

// Reorder the alternatives so that shorter common prefix lookahead paths appears after the longer ones.
// i.e. longer ones first
HSimpleContainer:= { <ObjectPart> | <HMessageBox> |  TkIdentifier }
HContainer:= { <HChunk> <HSimpleContainer> | <HSimpleContainer> }
HMessageBox:=[ the ] TkMsgsyn { box | window }
HChunk:={ TkCharsyn <HChunk_1> | word <HChunk_1> | item <HChunk_1> | line <HChunk_1> | <HOrdinal> TkCharsyn | <HOrdinal> word | <HOrdinal> item | <HOrdinal> line  } <Of>
HChunk_1:= <MAYBEFACTOR> [ to <MAYBEFACTOR> ]
HAdjective:={ long | short | abbrev | abbr | abbreviated }


//////////// Objects
Object:={ <ObjectBtn> | <ObjectFld> | <ObjectCard> | <ObjectBg> | <ObjectStack> | <Object_1> | TkProductname | me }
Object_1:=[ the ] target
ObjectBtn:={TkCardsyn | TkBkgndsyn} {TkBtnsyn id <FACTOR> | TkBtnsyn <FACTOR> | <HOrdinal> TkBtnsyn} [ <Of> <ObjectCard> ]
ObjectFld:={TkCardsyn | TkBkgndsyn} {TkFldsyn id <FACTOR> | TkFldsyn <FACTOR> | <HOrdinal> TkFldsyn} [ <Of> <ObjectCard> ]
ObjectCard:={ TkCardsyn id <FACTOR> | TkCardsyn <FACTOR> | <HOrdinal> TkCardsyn | <HPosition> TkCardsyn  }
ObjectBg:={TkBkgndsyn id <FACTOR> | TkBkgndsyn <FACTOR> | <HOrdinal> TkBkgndsyn | <HPosition> TkBkgndsyn }
ObjectStack:=this stack 
ObjectPart:={<ObjectBtn> | <ObjectFld> }

///////////// Command Nonterminals
NtDest:={ <ObjectCard> | <ObjectBg> | <ObjectStack> }
NtPreposition:={ before | after | into}
NtTextStyleList:=ATLEASTONE{{   <NtTextStyle> }}ENDATLEASTONE
NtTextStyle:={plain | bold | italic | underline | outline |shadow | condense | extend} 
//NtVisEffect:= <NtVisEffectKind> [ TkIdentifier [TkIdentifier] ]  [ to { TkCardsyn | TkIdentifier } ]
//NtVisEffectKind:= [TkIdentifier] { TkIdentifier | to | from | push | plain }  [{ open | close | left | right | up | down | out | TkInOnly | top | bottom | center }]

// we'll have to interpret this at runtime anyways. was causing parsing problems so why bother
NtVisEffect:= ATLEASTONE{{   <NtVisEffectTerm> }}ENDATLEASTONE
NtVisEffectTerm:= { TkIdentifier |  to | from | push | plain | open | close | left | right | up | down | out | TkInOnly | top | bottom | center }

NtChooseToolName:= { TkIdentifier TkIdentifier | TkIdentifier | TkBtnsyn | TkFldsyn | rect | select | text | line }
NtHotKey:={shiftkey | optionkey | commandkey}

////////// Commands
//BuiltinCmds:={<BuiltinCmdAdd>|<BuiltinCmdAsk>|<BuiltinCmdBeep>|<BuiltinCmdChoose>|<BuiltinCmdClick>|<BuiltinCmdDelete>|<BuiltinCmdDisable>|<BuiltinCmdEnable>|<BuiltinCmdDivide>|<BuiltinCmdDrag>|<BuiltinCmdGoCard>|<BuiltinCmdHide>|<BuiltinCmdLock>|<BuiltinCmdMultiply>|<BuiltinCmdReset>|<BuiltinCmdSubtract>|<BuiltinCmdUnlock>|<BuiltinCmdVisual>|<BuiltinCmdWait>|<BuiltinCmdAnswer>|<BuiltinCmdGet>|<BuiltinCmdPut>|<BuiltinCmdSet>|<BuiltinCmdShow>|<BuiltinCmdSort>}
BuiltinCmdAdd:=add <ARITH> to <HContainer>
BuiltinCmdAnswer:=answer <FACTOR> [with <FACTOR> [ or <FACTOR> [ or <FACTOR>]]]
BuiltinCmdAsk:=ask [password] <Expr> [with <Expr>]
BuiltinCmdBeep:=beep [<Expr>]
BuiltinCmdChoose:={ choose tool <MAYBE_ALLOW_ARITH> | choose <NtChooseToolName> tool }
BuiltinCmdClick:=click at <MAYBE_ALLOW_ARITH> TkComma <MAYBE_ALLOW_ARITH> [ with <NtHotKey> [ TkComma <NtHotKey> [ TkComma <NtHotKey> ] ] ]
BuiltinCmdDelete:=delete { <HChunk> <HSimpleContainer> | <ObjectPart> }
BuiltinCmdDisable:=disable <ObjectBtn>
BuiltinCmdDivide:=divide <HContainer> by <ARITH>
BuiltinCmdDrag:=drag from <MAYBE_ALLOW_ARITH> TkComma <MAYBE_ALLOW_ARITH> to <MAYBE_ALLOW_ARITH> TkComma <MAYBE_ALLOW_ARITH> [ with <NtHotKey> [ TkComma <NtHotKey> [ TkComma <NtHotKey> ] ] ]
BuiltinCmdEnable:=enable <ObjectBtn>
// I don't see why "get" would need anything special for accessing properties... any <Expr> can already access properties.
BuiltinCmdGet:=get <Expr>
BuiltinCmdGoCard:=go [ to ] { <NtDest> | <HOrdinal> | <HPosition> }
BuiltinCmdHide:=hide { <ObjectPart> | menubar }
BuiltinCmdLock:=lock { error dialogs | screen | messages |  recent}
BuiltinCmdMultiply:=multiply <HContainer> by <ARITH>
BuiltinCmdPut:=put <Expr> [ <NtPreposition> [ <HContainer> ]]
BuiltinCmdReset:=reset { paint | menubar | printing }
BuiltinCmdSet:=set [the] <AnyPropertyName> [ TkOfOnly { <HChunk> <ObjectFld> | <Object> } ] to <AnyPropertyVal>
BuiltinCmdShow:=show { <BuiltinCmdShow_1>  | <BuiltinCmdShow_2> | menubar }
BuiltinCmdShow_1:=<ObjectPart> [ at  <MAYBE_ALLOW_ARITH> TkComma <MAYBE_ALLOW_ARITH> ]
BuiltinCmdShow_2:=[ all ] TkCardssyn
//// we don't yet support sort by expression where the value of 'each' is set to each line -- might be too slow to be done synchronously
BuiltinCmdSort:=sort [ {ascending | descending} ] [ {text | numeric | international | datetime} ] { lines | items } <Of> <HContainer>
BuiltinCmdSubtract:=subtract <ARITH> from <HContainer>
BuiltinCmdUnlock:=unlock screen [ with [ visual [ effect ] ] <NtVisEffect> ]
BuiltinCmdVisual:=visual [ effect ] <NtVisEffect>
BuiltinCmdWait:=wait [for] <Expr> { TkIdentifier | second }

//////////// syntax keywords
// on handler -- interpretted before reaching the parser
// end handler -- interpretted before reaching the parser
// return <expression> -- interpretted before reaching the parser
// exit handler -- interpretted before reaching the parser
// exit repeat -- interpretted before reaching the parser
// next repeat -- interpretted before reaching the parser
// pass handler -- interpretted before reaching the parser
// exit to productname -- interpretted before reaching the parser
// global var1, var2 -- interpretted before reaching the parser
// send expr ... sometimes nice to have, but not needed
// if x then doSomething -- not supported
// if x then -- interpretted before reaching the parser
// else if y then -- interpretted before reaching the parser
// end if -- interpretted before reaching the parser
// repeat with -- interpretted before reaching the parser
// end repeat -- interpretted before reaching the parser

///////// Properties
AnyPropertyName:= {  right | left | bottom |top | rect | id | TkIdentifier  }

// we want AnyPropertyVal to take TkIdentifier | up | down | right | left | center | shadow.
// well TkIdentifier can be a AnyPropertyVal_ValPtOrRect (treated as variable)
// and up and down are AnyPropertyVal_ValPtOrRect (going down to ExprSource, ExprLiteral, constants)
// shadow can be taken by NtTextStyleList 
AnyPropertyVal:= { <AnyPropertyVal_ValPtOrRect> | <NtTextStyleList> | right | left | center }
AnyPropertyVal_ValPtOrRect:= <MAYBE_ALLOW_ARITH> [ TkComma <MAYBE_ALLOW_ARITH> [ TkComma <MAYBE_ALLOW_ARITH> TkComma <MAYBE_ALLOW_ARITH> ]]               
Of:={TkOfonly|TkInOnly}   

///////// Function calls
FnCall:= { the length TkOfOnly <FACTOR> | <FnCallWithParens> | <FnCallAllowedNoParensTarget> | <FnCallNumberOf> | <ExprThereIs> | the result | the paramcount | the params  }
FnCallAllowedNoParensTarget:= the [ <HAdjective> ] target
FnCallNumberOf:= the number TkOfOnly { <FnCallNumberOf_3> | <FnCallNumberOf_2> |  <Object>  | <FnCallNumberOf_1> |  TkBkgndssyn  }
FnCallNumberOf_1:= TkCardssyn [ <Of> <ObjectBg> ] 
FnCallNumberOf_2:= [ {TkCardsyn | TkBkgndsyn} ] { TkBtnssyn | TkFldssyn }
FnCallNumberOf_3:= { TkCharsyn | words | items | lines} <Of> <FACTOR>
FnCallWithParens:=[the] [ <HAdjective> ] { TkIdentifier | length | result | paramcount | params | target | commandkey | shiftkey | optionkey | tool  } TkLParen MANYSEP{{ TkComma / <Expr> }}ENDMANYSEP  TkRParen 

////////////Expressions
// ExprLiteral used to have TkIdentifier, but HSimpleContainer takes a TkIdentifier
ExprSource:={ <ExprGetProperty>| <FnCall> | <HSimpleContainer> | TkStringLiteral | TkNumber | up | down | true | false }
ExprGetProperty:=[the] [ <HAdjective> ] <AnyPropertyName> TkOfOnly { <HChunk> <ObjectFld> | <Object> } 
ExprThereIs:=there is { an | TkA | no | not TkA } <Object>
Expr:= <Lvl1Expression> MANY{{ <OpLogicalOrAnd> <Lvl1Expression> }}ENDMANY
Lvl1Expression:= <Lvl2Expression> MANY{{ <OpContainingEqualityGreaterLess> <Lvl2Expression> }}ENDMANY
Lvl2Expression:= <Lvl3Expression> [ is [not] { TkA | an } { number | integer | point | rect | logical } ]
Lvl3Expression:= <Lvl4Expression> MANY{{ <OpStringConcat> <Lvl4Expression> }}ENDMANY
Lvl4Expression:= <Lvl5Expression> MANY{{ <OpPlusMinus> <Lvl5Expression> }}ENDMANY
Lvl5Expression:= <Lvl6Expression> MANY{{ <OpMultDivideExp> <Lvl6Expression> }}ENDMANY
Lvl6Expression:= [ { TkMinus | not } ] [<HChunk>] { <ExprSource> | TkLParen <Expr> TkRParen }


////////////Operators
OpLogicalOrAnd:= {or | and}
OpContainingEqualityGreaterLess:= { <OpContainingWithin> | is not | TkGreaterEqual | TkLessEqual | TkGreater | TkLess | TkEquals  | is | TkNotEqBasicStyle | TkNotEqCStyle  }
OpContainingWithin:= {  is TkInOnly | contains | is not TkInOnly | is within | is not within }
OpStringConcat:= { TkConcatDouble | TkConcatSingle }
OpPlusMinus:= { TkPlus | TkMinus }
OpMultDivideExp:= { TkMult | TkDivide | TkCaret | div | mod }

///////////// top level, generated in 'lines.ts'
//TopLevel:={<TopLevelRequestEval> | <TopLevelRequestHandlerCall> | <TopLevelRequestUserFnCall> | <TopLevelRepeatWith> | <BuiltinCmds>}
TopLevelRequestEval:=TkRequestEval <Expr>
//TopLevelRequestHandlerCall:=TkRequestHandlerCall TkIdentifier MANYSEP{{ TkComma / <Expr> }}ENDMANYSEP 
//TopLevelRequestUserFnCall:=TkRequestUserFnCall TkIdentifier TkLParen MANYSEP{{ TkComma / <Expr> }}ENDMANYSEP TkRParen
//TopLevelRepeatWith:= repeat with TkIdentifier TkEquals <Expr> [down] to <Expr>

///////////////////////////////////////////////////////////// 


----End:Rules--------


----Begin:Checks--------
// we need to use TkCardsyn and not "card" 
AssertNotToken|bkgnd|bg|card|cd|button|btn|field|fld|char|character|msg|message|prev|previous
AssertNotToken|bkgnds|bgs|cards|cds|buttons|btns|fields|flds
AssertNotToken|of|in

Rule Should Accept Any Of These|AnyPropertyName|listfunctions.txt|ListProperties
//Rule Should Accept Any Of These|AnyPropertyVal|listfunctions.txt|ListStyles
//Rule Should Accept Any Of These|AnyPropertyVal|right/left/center|

Rule Should Accept Any Of These|FnCallWithParens|listfunctions.txt|ListFunctions
//Rule Should Accept Any Of These|ExprSource|listfunctions.txt|ListConstants

Rule Should Accept Any Of These|NtVisEffectTerm|very/slow/slowly/fast|
Rule Should Accept Any Of These|NtVisEffectTerm|card/black/white/gray/grey/inverse|
Rule Should Accept Any Of These|NtVisEffectTerm|barn/door/open/close/cut/plain/dissolve/venetian/blinds/checkerboard/iris/open/close/scroll/left/right/up/down/wipe/left/right/up/down/zoom/open/out/close/in/shrink/to/top/bottom/center/stretch/from/top/bottom/center/push/left/right/up/down/|
Rule Should Accept Any Of These|NtChooseToolName|/browse/button/field/select/lasso/pencil/brush/eraser/line/spray/can/rect/round/rect/bucket/oval/curve/text/reg/regular/polygon/poly/|
//Rule Should Accept Any Of These|BuiltinCmdWait|ticks/tick/seconds/second/sec|


----End:Checks--------


----Begin:Directives--------
// one reason to use FACTOR is that it can't have the term "or" (unless in parens) and so it won't interfere with answer "a" with "b" or "c", which would otherwise be parsed as answer "a" with "true" because ("b" or "c" is true)
InRulesReplaceWholeWord|FACTOR|Lvl6Expression
InRulesReplaceWholeWord|MAYBEFACTOR|Lvl6Expression
InRulesReplaceWholeWord|MAYBE_ALLOW_ARITH|Lvl4Expression
InRulesReplaceWholeWord|ARITH|Lvl4Expression
----End:Directives--------

