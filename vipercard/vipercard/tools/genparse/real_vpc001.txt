
Why not implement the "select" command?

Things the app code (should?) check for:
    NtVisEffectKind will get not only "plain" (expected), but font styles 
    AnyPropertyVal will get "shadow" as both a button style and a font style
    Anything using TkCharOrWordOrItemOrLineOrPlural should check if it's ok to be plural or not
    Anything using TkCardOrPluralSyn et al  should check if it's ok to be plural or not
    

----Begin:Tokens--------
// Be careful when lexing because tokens are greedy. If you have 3 tokens /fro/ /from/ /frome/,
// the string "from frome" becomes [fro, m, fro, me].
// the (?![a-zA-Z0-9_]) means to look ahead to make sure no other word/letters are there.
// important, otherwise if you have tokens "the" and "then", you'd need to order everything right, or "then" would lex into "the", "n"
TkBkgndOrPluralSyn=OneOfWords(backgrounds?,bkgnds?,bgs?)
TkCardOrPluralSyn=OneOfWords(cards?,cds?)
TkBtnOrPluralSyn=OneOfWords(buttons?,btns?)
TkFldOrPluralSyn=OneOfWords(fields?,flds?)
TkMsgsyn=OneOfWords(message,msg)
TkPrevOrNextsyn=OneOfWords(previous,prev,next)
TkOfOnly=OneOfWords(of)
TkInOnly=OneOfWords(in)
TkA=OneOfWords(a)
TkProductname=new RegExp(cProductName + '(?![a-zA-Z0-9_])', 'i')

TkOtherFontStyle=OneOfWords(plain,shadow,bold,italic,underline,outline,condense,extend)
TkAdjective=OneOfWords(long,short,abbreviated,abbrev,abbr)
TkDivMod=OneOfWords(div,mod)
TkResultOrParamcountOrParams=OneOfWords(result,paramcount,params)
TkCharOrWordOrItemOrLineOrPlural=OneOfWords(characters?,chars?,words?,items?,lines?)

// add this for faster parsing
TkHOrdinalEnglishWord=OneOfWords(last,mid,middle,any,first,second,third,fourth,fifth,sixth,seventh,eigth,ninth,tenth)

TkRequestEval=/\$\$RequestEval(?![a-zA-Z0-9_])/
// TkRequestEval TkComma to call something from the top. use the special TkRequestEval token so parsing won't ever accidentally fall here 
// I'm trying to reduce the number of tokens used, for better perf.
// and, in an effort to reduce the number of tokens even further,
// use the fact that Chevrotain has no special starting rule, any of the grammar rules can be invoked as the starting rule.
// so, from the line analysis stage, look at the first token and call one of the rules as appropriate. (if token[0] == 'add' call parser.StmtAdd() )
// I'm reducing the number of tokens kind of absurdly, ideally tokens with different semantics (== vs >=) should still be separate
// I spent like 6 hours reducing the number of tokens from over 170 to under 60.

TkGreaterOrLessEqualOrEqual=/>=|<=|<>|>|<|!=|==/
TkEquals=/=/
TkConcatSingleOrDouble=/&&?/
TkMultDivideExp=/\*|\/|\^/
TkPlus=/\+/
TkMinus=/-/
TkComma=/,/
TkLParen=/\(/
TkRParen=/\)/

// reserved words. use cannot create a variable with these names.
// probably want to have 
the=SAME
with=SAME
this=SAME
to=SAME
target=SAME
id=SAME
stack=SAME
number=SAME
or=SAME
me=SAME

// maybe could get rid of, but let's leave for now
from=SAME
select=SAME
password=SAME
at=SAME
by=SAME
all=SAME
length=SAME
there=SAME
is=SAME
an=SAME
no=SAME
not=SAME
and=SAME
contains=SAME
within=SAME

// space, literals
// possible to use 0|[1-9]\d+ to disallow 00123, I don't care right now.
TkNumber=/[0-9]+(\.[0-9]+)?/
TkContinuedLine=/\\\n/|||||static GROUP = ChvLexer.SKIPPED;static LINE_BREAKS = true
TkNewLine=/\n+/|||||static LINE_BREAKS = true
TkStringLiteral=/"[^"\n]*"/
TkWhiteSpace=/[ \t]+/|||||static GROUP = ChvLexer.SKIPPED

// should be last
TkIdentifier=/[a-zA-Z][0-9a-zA-Z_]*/
----End:Tokens--------



----Begin:Rules--------

//////////////////////////////////////////////////////// 

// there are several semi-keywords, like "transparent". You can use the term transparent with no parens like set the style to transparent,
// but also create a variable (put "abc" into transparent) with no problem. so is "transparent" a keyword or not?
// the product is very lenient -- you can even assign over functions (put "abc" into cos; answer cos && cos)
// note that if we made "transparent" et all a token, then it would be difficult to allow a variable named transparent. also, we'd have nearly 100 more tokens to deal with.
// let's use this approach:
//      certain terms are reserved keywords like "word", "item". defined as tokens, cannot be used as variable names at all.
//      certain terms are built-in properties/functions. "cos", "mouseloc". not defined as tokens. if you try 'put "abc" into cos' we check at runtime and error then.
//      certain terms are allowed as variable names and understood in some contexts. like "transparent" or "gray".
//      another benefit: user typos like "autoHilite2" don't create a mysterious syntax error, can have a better error message, "unknown property"

// note that in the product, nearly all functions can be used without parens. ("the sin of 4" == "sin(4)"). I don't like this, so I'm not implementing it.

// a bit of a space/time tradeoff.
// when we cram everything into one rule, slightly less space in memory taken as CST has fewer branches
// however, this also means slightly longer time in traversing as there are many conditionals to see which subrule is not null

///////////// Chunks and Prepositions
HOrdinal:=[ the ] TkHOrdinalEnglishWord
HPosition:={this | TkPrevOrNextsyn | the TkPrevOrNextsyn }
HSimpleContainer:= { <ObjectPart> | <HMessageBox> | TkIdentifier }
HContainer:= { <HChunk> <HSimpleContainer> | <HSimpleContainer> }
HMessageBox:=[ the ] TkMsgsyn TkIdentifier
HChunk:={  <HOrdinal> TkCharOrWordOrItemOrLineOrPlural | TkCharOrWordOrItemOrLineOrPlural <HChunk_1> } <Of>
HChunk_1:= <MAYBEFACTOR> [ to <MAYBEFACTOR> ]


//////////// Objects
Object:={ TkProductname | me | <Object_1> | <ObjectBtn> | <ObjectFld> | <ObjectCard> | <ObjectBg> | <ObjectStack> }
Object_1:=[ the ] target [ TkLParen TkRParen ]
ObjectBtn:={TkBtnOrPluralSyn id <FACTOR> | TkBtnOrPluralSyn <FACTOR> | <HOrdinal> TkBtnOrPluralSyn} [ <Of> <ObjectCard> ]
ObjectFld:={TkFldOrPluralSyn id <FACTOR> | TkFldOrPluralSyn <FACTOR> | <HOrdinal> TkFldOrPluralSyn} [ <Of> <ObjectCard> ]
ObjectCard:={ TkCardOrPluralSyn id <FACTOR> | TkCardOrPluralSyn <FACTOR> | <HOrdinal> TkCardOrPluralSyn | <HPosition> TkCardOrPluralSyn  }
ObjectBg:={TkBkgndOrPluralSyn id <FACTOR> | TkBkgndOrPluralSyn <FACTOR> | <HOrdinal> TkBkgndOrPluralSyn | <HPosition> TkBkgndOrPluralSyn }
ObjectStack:=this stack 
ObjectPart:={<ObjectBtn> | <ObjectFld> }

///////////// Command Nonterminals
NtDest:={ <ObjectCard> | <ObjectBg> | <ObjectStack> }
NtTextStyleList:=ATLEASTONE{{   TkOtherFontStyle }}ENDATLEASTONE
NtVisEffect:= <NtVisEffectKind> [ TkIdentifier [TkIdentifier] ]  [ to { TkCardOrPluralSyn | TkIdentifier } ]
NtVisEffectKind:= [TkIdentifier] { TkIdentifier | to | from  | TkOtherFontStyle }  [{ TkIdentifier  | TkInOnly }]
NtChooseToolName:= { TkBtnOrPluralSyn | TkFldOrPluralSyn | select  | TkCharOrWordOrItemOrLineOrPlural | TkIdentifier TkIdentifier | TkIdentifier }

////////// Commands
BuiltinCmdAdd:= TkRequestEval TkComma  <ARITH> to <HContainer>
//BuiltinCmdAnswer:= TkRequestEval TkComma  <FACTOR> [with <FACTOR> [ or <FACTOR> [ or <FACTOR>]]]
//BuiltinCmdAsk:= TkRequestEval TkComma  [password] <Expr> [with <Expr>]
//BuiltinCmdBeep:= TkRequestEval TkComma  [<Expr>]
//BuiltinCmdChoose:= TkRequestEval TkComma {  TkIdentifier <MAYBE_ALLOW_ARITH> | <NtChooseToolName> TkIdentifier }
//BuiltinCmdClick:= TkRequestEval TkComma  at <MAYBE_ALLOW_ARITH> TkComma <MAYBE_ALLOW_ARITH> [ with TkIdentifier [ TkComma TkIdentifier [ TkComma TkIdentifier ] ] ]
//BuiltinCmdDelete:= TkRequestEval TkComma  { <HChunk> <HSimpleContainer> | <ObjectPart> }
//BuiltinCmdDisable:= TkRequestEval TkComma  <ObjectBtn>
//BuiltinCmdDivide:= TkRequestEval TkComma  <HContainer> by <ARITH>
//BuiltinCmdDrag:= TkRequestEval TkComma  from <MAYBE_ALLOW_ARITH> TkComma <MAYBE_ALLOW_ARITH> to <MAYBE_ALLOW_ARITH> TkComma <MAYBE_ALLOW_ARITH> [ with TkIdentifier [ TkComma TkIdentifier [ TkComma TkIdentifier ] ] ]
//BuiltinCmdEnable:= TkRequestEval TkComma  <ObjectBtn>
//// I don't see why "get" would need anything special for accessing properties... any <Expr> can already access properties.
//BuiltinCmdGet:= TkRequestEval TkComma  <Expr>
//BuiltinCmdGoCard:= TkRequestEval TkComma  [ to ] {<HOrdinal> | <HPosition>  | <NtDest>}
//BuiltinCmdHide:= TkRequestEval TkComma  {  <ObjectPart> | TkIdentifier }
//BuiltinCmdLock:= TkRequestEval TkComma TkIdentifier
//BuiltinCmdMultiply:= TkRequestEval TkComma  <HContainer> by <ARITH>
//BuiltinCmdPut:= TkRequestEval TkComma  <Expr> [ TkIdentifier [ <HContainer> ]]
//BuiltinCmdReset:= TkRequestEval TkComma TkIdentifier
//BuiltinCmdSet:= TkRequestEval TkComma  [the] <AnyPropertyName> [ <OfOnly> { <Object> | <HChunk> <ObjectFld> } ] to <AnyPropertyVal>
//BuiltinCmdShow:= TkRequestEval TkComma  { <BuiltinCmdShow_1>  | <BuiltinCmdShow_2> | TkIdentifier }
//BuiltinCmdShow_1:= <ObjectPart> [ at  <MAYBE_ALLOW_ARITH> TkComma <MAYBE_ALLOW_ARITH> ]
//BuiltinCmdShow_2:= [ {all  | <ARITH>} ] TkCardOrPluralSyn
// we don't yet support sort by expression where the value of 'each' is set to each line -- might be too slow to be done synchronously
//BuiltinCmdSort:= TkRequestEval TkComma  [TkIdentifier ] [ TkIdentifier  ] TkIdentifier <Of> <HContainer>
//BuiltinCmdSubtract:= TkRequestEval TkComma  <ARITH> from <HContainer>
//BuiltinCmdUnlock:= TkRequestEval TkComma  TkIdentifier [ with [ TkIdentifier [ TkIdentifier ] ] <NtVisEffect> ]
//BuiltinCmdVisual:= TkRequestEval TkComma  [ TkIdentifier ] <NtVisEffect>
//// let's have the line analyser eat the token "for" if it exists.
//BuiltinCmdWait:= TkRequestEval TkComma <Expr> TkIdentifier 

//////////// syntax keywords
// on handler -- interpretted before reaching the parser
// end handler -- interpretted before reaching the parser
// return <expression> -- interpretted before reaching the parser
// exit handler -- interpretted before reaching the parser
// exit repeat -- interpretted before reaching the parser
// next repeat -- interpretted before reaching the parser
// pass handler -- interpretted before reaching the parser
// exit to productname -- interpretted before reaching the parser
// global var1, var2 -- interpretted before reaching the parser
// send expr ... sometimes nice to have, but not needed
// if x then doSomething -- not supported
// if x then -- interpretted before reaching the parser
// else if y then -- interpretted before reaching the parser
// end if -- interpretted before reaching the parser
// end repeat -- interpretted before reaching the parser

///////// Properties
AnyPropertyName:= {   id | TkIdentifier  }
AnyPropertyVal:= { TkIdentifier  | <NtTextStyleList> | <AnyPropertyVal_ValPtOrRect> }
AnyPropertyVal_ValPtOrRect:= <MAYBE_ALLOW_ARITH> [ TkComma <MAYBE_ALLOW_ARITH> [ TkComma <MAYBE_ALLOW_ARITH> TkComma <MAYBE_ALLOW_ARITH> ]] 
OfOnly:=TkOfonly                
Of:={TkOfonly|TkInOnly}   

///////// Function calls
FnCall:= { the length <Of> <FACTOR> | the TkResultOrParamcountOrParams | <FnCallNumberOf> | <ExprThereIs> | <FnCallAllowedNoParensTarget> | <FnCallWithParens> }
FnCallAllowedNoParensTarget:= the [ TkAdjective ] target
FnCallNumberOf:= the number <Of> { TkBkgndOrPluralSyn | <FnCallNumberOf_1> | <FnCallNumberOf_2> | <FnCallNumberOf_3> | <Object> }
FnCallNumberOf_1:= TkCardOrPluralSyn [ <Of> <ObjectBg> ] 
FnCallNumberOf_2:= [ {TkCardOrPluralSyn | TkBkgndOrPluralSyn} ] { TkBtnOrPluralSyn | TkFldOrPluralSyn }
FnCallNumberOf_3:= TkCharOrWordOrItemOrLineOrPlural <Of> <FACTOR>
FnCallWithParens:=[the] [ TkAdjective ] { TkIdentifier | length | TkResultOrParamcountOrParams | target   } TkLParen MANYSEP{{ TkComma / <Expr> }}ENDMANYSEP  TkRParen 

////////////Expressions
ExprSource:={ <ExprLiteral> |  <HSimpleContainer> | <FnCall> | <ExprGetProperty> }
ExprGetProperty:=[the] [ TkAdjective ] <AnyPropertyName> <Of> { <Object> | <HChunk> <ObjectFld> } 
ExprLiteral:={ TkStringLiteral | TkNumber | TkIdentifier  }
ExprThereIs:=there is { an | TkA | no | not TkA } <Object>
Expr:= <Lvl1Expression> MANY{{ <OpLogicalOrAnd> <Lvl1Expression> }}ENDMANY
Lvl1Expression:= <Lvl2Expression> MANY{{ <OpContainingEqualityGreaterLess> <Lvl2Expression> }}ENDMANY
Lvl2Expression:= <Lvl3Expression> [ is [not] { TkA | an } { number  | TkIdentifier } ]
Lvl3Expression:= <Lvl4Expression> MANY{{ <OpStringConcat> <Lvl4Expression> }}ENDMANY
Lvl4Expression:= <Lvl5Expression> MANY{{ <OpPlusMinus> <Lvl5Expression> }}ENDMANY
Lvl5Expression:= <Lvl6Expression> MANY{{ <OpMultDivideExp> <Lvl6Expression> }}ENDMANY
Lvl6Expression:= [ { TkMinus | not } ] [<HChunk>] { <ExprSource> | TkLParen <Expr> TkRParen }


////////////Operators
OpLogicalOrAnd:= {or | and}
OpContainingEqualityGreaterLess:= {  TkGreaterOrLessEqualOrEqual | TkEquals | <OpContainingWithin> | is not | is   }
OpContainingWithin:= {  is TkInOnly | contains | is not TkInOnly | is within | is not within }
OpStringConcat:= TkConcatSingleOrDouble
OpPlusMinus:= { TkPlus | TkMinus }
OpMultDivideExp:= { TkMultDivideExp | TkConcatSingleOrDouble | TkDivMod }

///////////// top level, generated in 'lines.ts'
TopLevelRequestEval:=TkRequestEval TkComma <Expr>
TopLevelRequestHandlerCall:=TkRequestEval TkComma TkIdentifier MANYSEP{{ TkComma / <Expr> }}ENDMANYSEP 
TopLevelRequestUserFnCall:=TkRequestEval TkComma TkIdentifier TkLParen MANYSEP{{ TkComma / <Expr> }}ENDMANYSEP TkRParen
TopLevelRepeatWith:=TkRequestEval TkComma TkIdentifier TkEquals <Expr> [TkIdentifier] to <Expr>

///////////////////////////////////////////////////////////// 


----End:Rules--------


----Begin:Checks--------
// we need to use TkCardOrPluralSyn and not "card" 
AssertNotToken|bkgnd|bg|card|cd|button|btn|field|fld|char|character|msg|message|prev|previous
AssertNotToken|bkgnds|bgs|cards|cds|buttons|btns|fields|flds
AssertNotToken|of|in

Rule Should Accept Any Of These|AnyPropertyName|listfunctions.txt|ListProperties
Rule Should Accept Any Of These|AnyPropertyVal|listfunctions.txt|ListStyles
Rule Should Accept Any Of These|AnyPropertyVal|right/left/center|
Rule Should Accept Any Of These|FnCallWithParens|listfunctions.txt|ListFunctions::params/ok/TkResultOrParamcountOrParams:paramcount/ok/TkResultOrParamcountOrParams:result/ok/TkResultOrParamcountOrParams
Rule Should Accept Any Of These|ExprLiteral|listfunctions.txt|ListConstants

Rule Should Accept Any Of These|NtVisEffect|very/slow/slowly/fast|
Rule Should Accept Any Of These|NtVisEffect|card/black/white/gray/grey/inverse|
Rule Should Accept Any Of These|NtVisEffectKind|barn/door/open/close/cut/plain/dissolve/venetian/blinds/checkerboard/iris/open/close/scroll/left/right/up/down/wipe/left/right/up/down/zoom/open/out/close/in/shrink/to/top/bottom/center/stretch/from/top/bottom/center/push/left/right/up/down/|
Rule Should Accept Any Of These|NtChooseToolName|/browse/button/field/select/lasso/pencil/brush/eraser/line/spray/can/rect/round/rect/bucket/oval/curve/text/reg/regular/polygon/poly/|
//Rule Should Accept Any Of These|BuiltinCmdChoose|/tool/|
//Rule Should Accept Any Of These|BuiltinCmdWait|ticks/tick/seconds/second/sec|
//Rule Should Accept Any Of These|BuiltinCmdSort|ascending/descending/text/numeric/international/datetime|
//Rule Should Accept Any Of These|BuiltinCmdUnlock|screen/visual/effect|
//Rule Should Accept Any Of These|BuiltinCmdVisual|effect|

//Rule Should Accept Any Of These|HOrdinal|last/mid/middle/any/first/second/third/fourth/fifth/sixth/seventh/eigth/ninth/tenth|
Rule Should Accept Any Of These|HMessageBox|box/window|
//Rule Should Accept Any Of These|BuiltinCmdPut|before/after/into|
Rule Should Accept Any Of These|Lvl2Expression|number/integer/point/rect/logical|
//Rule Should Accept Any Of These|BuiltinCmdClick|shiftkey/optionkey/commandkey|
//Rule Should Accept Any Of These|BuiltinCmdDrag|shiftkey/optionkey/commandkey|
//Rule Should Accept Any Of These|BuiltinCmdHide|menubar|
//Rule Should Accept Any Of These|BuiltinCmdReset|paint/menubar/printing|
//Rule Should Accept Any Of These|BuiltinCmdShow|menubar|
//Rule Should Accept Any Of These|BuiltinCmdLock|screen/messages/error/dialogs/recent|




//Referred To All Tokens Except|TokenTkcontinuedline|TokenTknewline|TokenTkwhitespace
Referred To All Tokens Except|TokenTkcontinuedline|TokenTknewline|TokenTkwhitespace|TokenAll|TokenWith|TokenPassword|TokenAt|TokenBy

----End:Checks--------


----Begin:Directives--------
// one reason to use FACTOR is that it can't have the term "or" (unless in parens) and so it won't interfere with answer "a" with "b" or "c", which would otherwise be parsed as answer "a" with "true" because ("b" or "c" is true)
InRulesReplaceWholeWord|FACTOR|Lvl6Expression
InRulesReplaceWholeWord|MAYBEFACTOR|Lvl6Expression
InRulesReplaceWholeWord|MAYBE_ALLOW_ARITH|Lvl4Expression
InRulesReplaceWholeWord|ARITH|Lvl4Expression
----End:Directives--------

