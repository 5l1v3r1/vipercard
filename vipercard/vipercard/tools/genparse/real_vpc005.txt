
BuiltinCmdClick, BuiltinCmdDrag should at runtime validate the 'hotkeys' given which can now be any Tkidentifier
BuiltinCmdChoose should make sure it actually gets 'tool'

----Begin:Tokens--------
// Be careful when lexing because tokens are greedy. If you have 3 tokens /fro/ /from/ /frome/,
// the string "from frome" becomes [fro, m, fro, me].
// the (?![a-zA-Z0-9_]) means to look ahead to make sure no other word/letters are there.
// important, otherwise if you have tokens "the" and "then", you'd need to order everything right, or "then" would lex into "the", "n"

// I really put time into reducing the number of tokens used, for better perf when lexing.
// use the fact that Chevrotain has no special starting rule, any of the grammar rules can be invoked as the starting rule.
// so, from the line analysis stage, look at the first token and call one of the rules as appropriate. (if token[0] == 'add' call parser.StmtAdd() )
// I'm reducing the number of tokens kind of absurdly, ideally tokens with different semantics (== vs >=) should still be separate
// possible alternative; Chevrotain supports dynamic lexing kinda for this purpose, you switch between sets of tokens based on context
// I spent like 9 hours reducing the number of tokens from over 170 to under 40.
// Good parts about reducing number of tokens:
//      lexing is faster. and we lex a lot.
//      user gets better error messages. if we made all builtin functions a token and disallowed custom functions, but then sin2(x) would be a syntax error
//      if rules have a lot of options like { first | second | third | fourth }, the visitor at runtime has to loop through them to check which is not-null which isn't ideal
// Bad parts about reducing number of tokens:
//      more analysis needed at runtime. although we already need to do a lot of analysis there anyways, so it's not so bad. do need to confirm the right words use though.
//      grammar is more fragile for chevrotain warning (false positive?) about ambiguities. the first time I stripped it down, see real_vpc001.txt, got a lot of Chev. warnings saying "same prefix" in both paths. unclear if actually a problem but I don't want to increase the llk.
//      grammar might have actual true wrong parsing. consider "ask [password] <Expr>". if I made it "ask [TkIdentifier] <Expr>" to try to save a token, if the user typed "ask x-3" it would be parsed as (ask)(x)(-3) and mess up the expression.
//      potentially slower parsing because there are potentially more routes the grammar can take as more keywords are moved to generic TkIdentifiers; might do more backtracking

// space, literals
// whitespace is common, so add it first for better perf
TkContinuedLineOrWhiteSpace=/[ \t]+|\\\n/|||||static GROUP = ChvLexer.SKIPPED;static LINE_BREAKS = true
TkNewLine=/\n+/|||||static LINE_BREAKS = true

// our line processing will generate TkNewLine called a TkSyntaxMarker
// we can reduce number of tokens during line processing by looking for terms like "from" or "into" and replacing them with this signal.
// a TkSyntaxMarker can be "from" "with" "password", BuiltinCmdPut's before/into/after.

// possible to use 0|[1-9]\d+ to disallow 00123, I don't care right now.
TkNumLiteral=/[0-9]+(\.[0-9]+)?/
TkStringLiteral=/"[^"\n]*"/
TkBkgndOrPluralSyn=OneOfWords(backgrounds?,bkgnds?,bgs?)
TkCardOrPluralSyn=OneOfWords(cards?,cds?)
TkBtnOrPluralSyn=OneOfWords(buttons?,btns?)
TkFldOrPluralSyn=OneOfWords(fields?,flds?)
TkMsgsyn=OneOfWords(message,msg)
TkOfOnly=OneOfWords(of)
TkInOnly=OneOfWords(in)
TkCharOrWordOrItemOrLineOrPlural=OneOfWords(characters?,chars?,words?,items?,lines?)

TkOrdinal=OneOfWords(last,mid,middle,any,first,second,third,fourth,fifth,sixth,seventh,eigth,ninth,tenth)
TkAdjective=OneOfWords(long,short,abbreviated,abbrev,abbr)
TkMultDivideExpDivMod=/\*|\/|\^|div(?![a-zA-Z0-9_])|mod(?![a-zA-Z0-9_])/i
TkGreaterOrLessEqualOrEqual=/>=|<=|<>|>|<|!=|==?/
TkConcatDoubleOrSingle=/&&?/
TkPlusOrMinus=/\+|-/
TkComma=/,/
TkLParen=/\(/
TkRParen=/\)/
TknA=OneOfWords(an?)

// reserved words. use cannot create a variable with these names.
the=SAME
to=SAME
stack=SAME
or=SAME
length=SAME
number=SAME
there=SAME
is=SAME
not=SAME
and=SAME
contains=SAME
id=SAME
within=SAME

// tried getting rid of id, but led to chev. warning

// should be last
TkIdentifier=new RegExp('[a-zA-Z][0-9a-zA-Z_]*')
----End:Tokens--------



----Begin:Rules--------

//////////////////////////////////////////////////////// 

// there are several semi-keywords, like "transparent". You can use the term transparent with no parens like set the style to transparent,
// but also create a variable (put "abc" into transparent) with no problem. so is "transparent" a keyword or not?
// the product is very lenient -- you can even assign over functions (put "abc" into cos; answer cos && cos)
// note that if we made "transparent" et all a token, then it would be difficult to allow a variable named transparent. also, we'd have nearly 100 more tokens to deal with.
// let's use this approach:
//      certain terms are reserved keywords like "word", "item". defined as tokens, cannot be used as variable names at all.
//      certain terms are built-in properties/functions. "cos", "mouseloc". not defined as tokens. if you try 'put "abc" into cos' we check at runtime and error then.
//      certain terms are allowed as variable names and understood in some contexts. like "transparent" or "gray".
//      another benefit: user typos like "autoHilite2" don't create a mysterious syntax error, can have a better error message, "unknown property"

// note that in the product, nearly all functions can be used without parens. ("the sin of 4" == "sin(4)"). I don't like this, so I'm not implementing it.

// a bit of a space/time tradeoff.
// when we cram everything into one rule, slightly less space in memory taken as CST has fewer branches
// however, this also means slightly longer time in traversing as there are many conditionals to see which subrule is not null

// Reorder the alternatives so that shorter common prefix lookahead paths appears after the longer ones.
// i.e. when you have a group { a | b | c } put the longer ones first. makes validation faster at least, might not make a difference at parse time.

///////////// Chunks and Prepositions


// BuildMapWithAllChildren
// GetChildOrImage
// GetChildOrImageFromAlternatives
// GetImageToEnum
// GenerateInfix
// NotYetImplemented
// NotReached
// Custom



HOrdinal:= [ the ] TkOrdinal                                                                                    --->string--->GetChildOrImage|TkOrdinal[0]
HPosition:= [ the ] TkIdentifier                                                                                --->string--->GetChildOrImage|TkIdentifier[0]

// emulator does allow setting a btn as a container, have no idea what this does/means.
// let's fail at runtime when visiting HSimpleContainer for now.
HSimpleContainer:= { <ObjectPart> | <HMessageBox> |  TkIdentifier }                                             --->RequestedContainerRef--->Custom
HContainer:= [<HChunk>] <HSimpleContainer>                                                                      --->RequestedContainerRef--->Custom
HMessageBox:=[ the ] TkMsgsyn TkIdentifier                                                                      --->NotReached
HChunk:={ TkCharOrWordOrItemOrLineOrPlural <HChunk_1> | <HOrdinal> TkCharOrWordOrItemOrLineOrPlural } <Of>      --->RequestedChunk--->Custom
HChunk_1:= <MAYBE_FACTOR> [ to <MAYBE_FACTOR> ]                                                                 --->NotReached


//////////// Objects
// should really only be "target" or "me" or "productname"        
Object_1:=[ the ] TkIdentifier                                                                                  --->RequestedObjRef--->Custom
Object:={ <ObjectBtn> | <ObjectFld> | <ObjectCard> | <ObjectBg> | <ObjectStack> | <Object_1>  }                 --->GetChildOrImageFromAlternatives
ObjectBtn:={TkCardOrPluralSyn | TkBkgndOrPluralSyn} {TkBtnOrPluralSyn id <FACTOR> | TkBtnOrPluralSyn <FACTOR>} [ <Of> <ObjectCard> ]                            --->RequestedObjRef--->Custom
ObjectFld:={TkCardOrPluralSyn | TkBkgndOrPluralSyn} {TkFldOrPluralSyn id <FACTOR> | TkFldOrPluralSyn <FACTOR>} [ <Of> <ObjectCard> ]                            --->RequestedObjRef--->Custom
ObjectCard:={ TkCardOrPluralSyn id <FACTOR> | TkCardOrPluralSyn <FACTOR> | <HOrdinal> TkCardOrPluralSyn | <HPosition> TkCardOrPluralSyn  } [ <Of> <ObjectBg> ]  --->RequestedObjRef--->Custom
ObjectBg:={TkBkgndOrPluralSyn id <FACTOR> | TkBkgndOrPluralSyn <FACTOR> | <HOrdinal> TkBkgndOrPluralSyn | <HPosition> TkBkgndOrPluralSyn } [ <Of> <ObjectStack> ]  --->RequestedObjRef--->Custom
ObjectStack:=TkIdentifier stack                                                                                 --->RequestedObjRef--->Custom
ObjectPart:={<ObjectBtn> | <ObjectFld> }                                                                        --->GetChildOrImageFromAlternatives

///////////// Command Nonterminals
NtDest:={ <ObjectCard> | <ObjectBg> | <ObjectStack> }                                                           --->GetChildOrImageFromAlternatives

// we'll have to interpret this at runtime anyways. was causing parsing problems so why bother
NtVisEffect:= ATLEASTONE{{   <NtVisEffectTerm> }}ENDATLEASTONE                                                  --->BuildMapWithAllChildren|
NtVisEffectTerm:= { TkIdentifier |  to    | TkInOnly  }                                                         --->string--->GetChildOrImageFromAlternatives


////////// Commands
// syntax rewriting will change the syntax in some commands. real_vpc000.txt is closer to actual syntax
BuiltinCmdAdd:=TkIdentifier <ARITH> to <HContainer>                                                             --->BuildMapWithAllChildren|

// we can't support these until we support async
BuiltinCmdAnswer:=TkIdentifier <FACTOR> [TkSyntaxMarker <FACTOR> [ or <FACTOR> [ or <FACTOR>]]]                 --->BuildMapWithAllChildren|
BuiltinCmdAsk:=TkIdentifier [TkComma] <Expr> [TkSyntaxMarker <Expr>]                                            --->BuildMapWithAllChildren|
BuiltinCmdWait:=TkIdentifier [TkSyntaxMarker] <Expr> { TkIdentifier | TkOrdinal  }                              --->BuildMapWithAllChildren|


BuiltinCmdBeep:=TkIdentifier [<Expr>]                                                                           --->BuildMapWithAllChildren|

BuiltinCmdChoose:=TkIdentifier  { TkSyntaxMarker <ChooseToolname_1> | <MAYBE_FACTOR> }                          --->BuildMapWithAllChildren|
ChooseToolname_1:= ATLEASTONE{{ <ChooseToolname_2>   }}ENDATLEASTONE                                            --->BuildMapWithAllChildren|
ChooseToolname_2:= { TkIdentifier | TkCharOrWordOrItemOrLineOrPlural}                                           --->string--->GetChildOrImageFromAlternatives

BuiltinCmdClick:=TkIdentifier TkIdentifier <MAYBE_ALLOW_ARITH> TkComma <MAYBE_ALLOW_ARITH> [ TkSyntaxMarker TkIdentifier [ TkComma TkIdentifier [ TkComma TkIdentifier ] ] ]  --->BuildMapWithAllChildren|
BuiltinCmdDelete:=TkIdentifier { <HChunk> <HSimpleContainer> | <ObjectPart> }                                   --->BuildMapWithAllChildren|
BuiltinCmdDisable:=TkIdentifier <ObjectBtn>                                                                     --->BuildMapWithAllChildren|
BuiltinCmdDivide:=TkIdentifier <HContainer> TkSyntaxMarker <ARITH>                                              --->BuildMapWithAllChildren|
BuiltinCmdDrag:=TkIdentifier TkIdentifier <MAYBE_ALLOW_ARITH> TkComma <MAYBE_ALLOW_ARITH> to <MAYBE_ALLOW_ARITH> TkComma <MAYBE_ALLOW_ARITH> [ TkSyntaxMarker TkIdentifier [ TkComma TkIdentifier [ TkComma TkIdentifier ] ] ]   --->BuildMapWithAllChildren|
BuiltinCmdEnable:=TkIdentifier <ObjectBtn>                                                                      --->BuildMapWithAllChildren|
BuiltinCmdGet:=TkIdentifier <Expr>                                                                              --->BuildMapWithAllChildren|

// ideally this would accept "back" and "forth". but I think it gets eaten by NtDest because HPosition accepts any TkIdentifier
// solution: during syntax rewriting, check if you were trying to say "go back" or "go forth".
BuiltinCmdGoCard:=TkIdentifier [ to ] { <NtDest> | <HOrdinal> | <HPosition> }                               --->BuildMapWithAllChildren|
BuiltinCmdHide:=TkIdentifier { <ObjectPart> | TkIdentifier }                                                --->BuildMapWithAllChildren|
BuiltinCmdLock:=TkIdentifier TkIdentifier                                                                   --->BuildMapWithAllChildren|
BuiltinCmdMultiply:=TkIdentifier <HContainer> TkSyntaxMarker <ARITH>                                        --->BuildMapWithAllChildren|

// TkIdentifier here is 'before' 'after' 'into'
// the traditional <Expr> [ TkIdentifier [ <HContainer> ]] which works for now, but breaks if an Expr can ever have 2 consecutive TkIdentifiers
// instead, add a TkSyntaxMarker during syntax rewrite
BuiltinCmdPut:=TkIdentifier <Expr> [ TkSyntaxMarker TkIdentifier TkSyntaxMarker [ <HContainer> ]]           --->BuildMapWithAllChildren|

BuiltinCmdReset:=TkIdentifier TkIdentifier                                                                  --->BuildMapWithAllChildren|
BuiltinCmdSet:=TkIdentifier [the] <AnyPropertyName> [ TkOfOnly { <HChunk> <ObjectFld> | <Object> } ] to <AnyPropertyVal>    --->BuildMapWithAllChildren|
BuiltinCmdShow:=TkIdentifier { <Show_1>  | <Show_2> | TkIdentifier }                                        --->BuildMapWithAllChildren|
Show_1:=<ObjectPart> [ TkSyntaxMarker <MAYBE_ALLOW_ARITH> TkComma <MAYBE_ALLOW_ARITH> ]                     --->BuildMapWithAllChildren|
Show_2:=[ TkIdentifier ] TkCardOrPluralSyn                                                                  --->BuildMapWithAllChildren|

//// we don't yet support sort by expression where the value of 'each' is set to each line -- might be too slow to be done synchronously. possible with syntax rewriting.
BuiltinCmdSort:=TkIdentifier MANY{{ TkIdentifier }}ENDMANY TkCharOrWordOrItemOrLineOrPlural <Of> <HContainer> --->BuildMapWithAllChildren|
BuiltinCmdSubtract:=TkIdentifier <ARITH> TkSyntaxMarker <HContainer>                                         --->BuildMapWithAllChildren|
BuiltinCmdUnlock:=TkIdentifier TkIdentifier [ TkIdentifier <NtVisEffect> ]                                   --->BuildMapWithAllChildren|
BuiltinCmdVisual:=TkIdentifier <NtVisEffect>                                                                 --->BuildMapWithAllChildren|

//////////// syntax keywords
// on handler -- interpretted before reaching the parser
// end handler -- interpretted before reaching the parser
// return <expression> -- interpretted before reaching the parser
// exit handler -- interpretted before reaching the parser
// exit repeat -- interpretted before reaching the parser
// next repeat -- interpretted before reaching the parser
// pass handler -- interpretted before reaching the parser
// exit to productname -- interpretted before reaching the parser
// global var1, var2 -- interpretted before reaching the parser
// send expr ... sometimes nice to have, but not needed
// if x then doSomething -- not supported
// if x then -- interpretted before reaching the parser
// else if y then -- interpretted before reaching the parser
// end if -- interpretted before reaching the parser
// repeat with -- interpretted before reaching the parser
// end repeat -- interpretted before reaching the parser

///////// Properties
AnyPropertyName:= {  id | TkIdentifier  }                                                                    --->string--->GetChildOrImageFromAlternatives

// we want AnyPropertyVal to take many things
// well TkIdentifier can be a MAYBE_ALLOW_ARITH (treated as variable)
// and shadow can be a MAYBE_ALLOW_ARITH (treated as variable)
// and left, right can be a MAYBE_ALLOW_ARITH (treated as variable)
// and center can be a MAYBE_ALLOW_ARITH (treated as variable)
// and up and down are MAYBE_ALLOW_ARITH (going down to ExprSource, ExprLiteral, constants)
// text style lists are in the form "bold, italic".
// let's be simpler and accept an arbitarary amnt of terms.
// point needs 2 terms, rect needs 4 terms, fonts need arbitrary number
AnyPropertyVal:= ATLEASTONESEP{{ TkComma / <MAYBE_ALLOW_ARITH> }}ENDATLEASTONESEP                           --->BuildMapWithAllChildren|
Of:={TkOfonly|TkInOnly}                                                                                     --->string--->GetChildOrImageFromAlternatives

///////// Function calls
// These are the only functions or function-like calls we allow without params
// the length of                 same as length("foo")
// the number of                 (no equivalent)
// the result                    same as result()
// the paramcount                same as paramcount()
// the params                    same as params()
// the target                    (no equivalent)
// the long target               (no equivalent)
// nyi: the long time            (no equivalent)
// then the global properties like
// the itemdelim
// the version

FnCall:= { <FnCall_Length> | <FnCallWithParens> | <FnCallWithoutParensOrGlobalGetPropOrTarget> | <FnCallNumberOf> | <ExprThereIs>  }   --->VpcVal--->GetChildOrImageFromAlternatives
FnCall_Length:=the length TkOfOnly <FACTOR>                                                                      --->VpcVal--->Custom
FnCallWithParens:=[the] { TkIdentifier | length } TkLParen MANYSEP{{ TkComma / <Expr> }}ENDMANYSEP  TkRParen     --->VpcVal--->Custom

// TkIdentifier should only be 'target,'result'   'params' or 'paramcount'
// note: this can also be a global property read. they look the same.
FnCallWithoutParensOrGlobalGetPropOrTarget:= the [ TkAdjective ] TkIdentifier                                    --->VpcVal--->Custom
FnCallNumberOf:= the number TkOfOnly { <FnCallNumberOf_1> | <FnCallNumberOf_2>  | <FnCallNumberOf_3> |  <FnCallNumberOf_4>  }   --->VpcVal--->GetChildOrImageFromAlternatives
FnCallNumberOf_1:= TkCharOrWordOrItemOrLineOrPlural <Of> <FACTOR>                                                --->VpcVal--->Custom
FnCallNumberOf_2:= {TkCardOrPluralSyn | TkBkgndOrPluralSyn} { TkBtnOrPluralSyn | TkFldOrPluralSyn }              --->VpcVal--->Custom
FnCallNumberOf_3:= TkCardOrPluralSyn [ <Of> <ObjectBg> ] [ <Of> <ObjectStack> ]                                  --->VpcVal--->Custom
FnCallNumberOf_4:= TkBkgndOrPluralSyn [ <Of> <ObjectStack> ]                                                     --->VpcVal--->Custom

// I didn't quite get this before, here's my current understanding:
// "lookahead" only comes into play when there is an OPTIONAL, OR, etc. block
// otherwise we'll greedily eat whatever comes our way.
// this issue arose when dealing with "x is y" versus "x is within y", had to make within a token so it wouldn't go the wrong way
// if the grammar is
// Expr1:= <Expr2> letterc Integer 
// Expr2:= letterb [letterc lettera]
// I would have hoped that "b c 123" would work, trying out Expr2 and then falling back to Expr1
// but no, once we go into Expr2 we can never fall back into Expr1.
// increasing the 'lookahead' parameter won't help.


////////////Expressions
// Confirmed in emulator that the product does not have short circuiting logic. set the autohilite of cd btn 1 to true. answer ((the autohilite of cd btn 1) or (the autohilite of cd btn 200)) still errors out.
// we could add this if we wanted to, by skipping the call to visit().

// ExprLiteral used to have TkIdentifier, but HSimpleContainer takes a TkIdentifier
ExprSource:={ <ExprGetProperty>| <FnCall> | <HSimpleContainer> | TkStringLiteral | TkNumLiteral  }               --->VpcVal--->Custom
ExprGetProperty:=[the] [ TkAdjective ] <AnyPropertyName> TkOfOnly { <HChunk> <ObjectFld> | <Object> }            --->VpcVal--->Custom
ExprThereIs:=there is [not] TknA <Object>                                                                        --->VpcVal--->Custom
Expr:= <Lvl1Expression> MANY{{ <OpLogicalOrAnd> <Lvl1Expression> }}ENDMANY                                       --->GenerateInfix|Lvl1Expression|OpLogicalOrAnd|this.evalHelp.evalOp|
Lvl1Expression:= <Lvl2Expression> MANY{{ <OpEqualityGreaterLessOrContains> <Lvl2Expression> }}ENDMANY            --->GenerateInfix|Lvl2Expression|OpEqualityGreaterLessOrContains|this.evalHelp.evalOp|
Lvl2Expression:= <Lvl3Expression> MANY{{ is  <Lvl2Sub>  }}ENDMANY                                                --->VpcVal--->Custom
Lvl2Sub:= [not]  { <Lvl2TypeCheck> | <Lvl2Within> | <Lvl3Expression> }                                           --->NotReached
Lvl2TypeCheck:= TknA { number  | TkIdentifier }                                                                  --->GetChildOrImageFromAlternatives
Lvl2Within:= {TkInOnly | within } <Lvl3Expression>                                                               --->NotReached

Lvl3Expression:= <Lvl4Expression> MANY{{ <OpStringConcat> <Lvl4Expression> }}ENDMANY                             --->GenerateInfix|Lvl4Expression|OpStringConcat|this.evalHelp.evalOp|
Lvl4Expression:= <Lvl5Expression> MANY{{ <OpPlusMinus> <Lvl5Expression> }}ENDMANY                                --->GenerateInfix|Lvl5Expression|OpPlusMinus|this.evalHelp.evalOp|
Lvl5Expression:= <Lvl6Expression> MANY{{ <OpMultDivideExpDivMod> <Lvl6Expression> }}ENDMANY                      --->GenerateInfix|Lvl6Expression|OpMultDivideExpDivMod|this.evalHelp.evalOp|
Lvl6Expression:= [ { TkPlusOrMinus | not } ] [<HChunk>] { <ExprSource> | TkLParen <Expr> TkRParen }              --->Custom


////////////Operators
OpLogicalOrAnd:= {or | and}                                                                                      --->GetChildOrImageFromAlternatives
OpEqualityGreaterLessOrContains:= { contains | TkGreaterOrLessEqualOrEqual  }                                    --->GetChildOrImageFromAlternatives
OpStringConcat:= TkConcatDoubleOrSingle                                                                          --->GetChildOrImage|TkConcatDoubleOrSingle[0]
OpPlusMinus:= TkPlusOrMinus                                                                                      --->GetChildOrImage|TkPlusOrMinus[0]
OpMultDivideExpDivMod:= TkMultDivideExpDivMod                                                                    --->GetChildOrImage|TkMultDivideExpDivMod[0]

///////////// top level, generated in 'lines.ts'
TopLevelRequestEval:=TkIdentifier <Expr>                                                                       --->BuildMapWithAllChildren|

// requesthandlerfncall^^ myhandler 45, 56
TopLevelRequestHandlerCall:=TkIdentifier TkIdentifier MANYSEP{{ TkComma / <Expr> }}ENDMANYSEP                 --->BuildMapWithAllChildren|



///////////////////////////////////////////////////////////// 


----End:Rules--------


----Begin:Checks--------
// we need to use TkCardOrPluralSyn and not "card" 
AssertNotToken|bkgnd|bg|card|cd|button|btn|field|fld|char|character|msg|message|prev|previous
AssertNotToken|bkgnds|bgs|cards|cds|buttons|btns|fields|flds
AssertNotToken|of|in

// text style is now just a bunch of identifiers, so they shouldn't be eaten by tokens
AssertNotToken|plain|bold|italic|underline|outline |shadow|condense|extend

Rule Should Accept Any Of These|HMessageBox|window/box|
Rule Should Accept Any Of These|AnyPropertyName|listfunctions.txt|ListProperties

// AnyPropertyVal has TkIdentifier via MAYBEARITH
Rule Should Accept Any Of These|AnyPropertyVal/hasTkIdentifier|listfunctions.txt|ListStyles
Rule Should Accept Any Of These|AnyPropertyVal/hasTkIdentifier|right/left/center|

// ExprSource has TkIdentifier via HSimpleContainer
Rule Should Accept Any Of These|ExprSource/hasTkIdentifier|listfunctions.txt|ListConstants

Rule Should Accept Any Of These|FnCallWithParens|listfunctions.txt|ListFunctions
Rule Should Accept Any Of These|FnCallWithParens|commandkey/optionkey/shiftkey|
Rule Should Accept Any Of These|NtVisEffectTerm|very/slow/slowly/fast|
Rule Should Accept Any Of These|NtVisEffectTerm|card/black/white/gray/grey/inverse|
Rule Should Accept Any Of These|NtVisEffectTerm|barn/door/open/close/cut/plain/dissolve/venetian/blinds/checkerboard/iris/open/close/scroll/left/right/up/down/wipe/left/right/up/down/zoom/open/out/close/in/shrink/to/top/bottom/center/stretch/from/top/bottom/center/push/left/right/up/down/|
// done in processing
//Rule Should Accept Any Of These|BuiltinCmdChoose|/browse/button/field/select/lasso/pencil/brush/eraser/line/spray/can/rect/round/rect/bucket/oval/curve/text/reg/regular/polygon/poly/|
//Rule Should Accept Any Of These|BuiltinCmdChoose|tool|


Rule Should Accept Any Of These|BuiltinCmdHide|menubar|
Rule Should Accept Any Of These|BuiltinCmdReset|paint/menubar/printing|
Rule Should Accept Any Of These|BuiltinCmdShow|menubar|
Rule Should Accept Any Of These|BuiltinCmdLock|screen/messages/error/dialogs/recent|
Rule Should Accept Any Of These|Show_2|all|
Rule Should Accept Any Of These|BuiltinCmdSort|ascending/descending/text/numeric/international/datetime/lines/items|::lines/ok/TkCharOrWordOrItemOrLineOrPlural:items/ok/TkCharOrWordOrItemOrLineOrPlural
Rule Should Accept Any Of These|BuiltinCmdWait|ticks/tick/seconds/second/sec|
Rule Should Accept Any Of These|BuiltinCmdWait|for|

Rule Should Accept Any Of These|Lvl2TypeCheck|number/integer/point/rect/logical|

Rule Should Accept Any Of These|BuiltinCmdUnlock|screen/with/visual/effect|
// has tkidentifier via NtVisEffect
Rule Should Accept Any Of These|BuiltinCmdVisual/hasTkIdentifier|effect|
Rule Should Accept Any Of These|HPosition|next/prev/previous/this/the|
Rule Should Accept Any Of These|BuiltinCmdGoCard/hasTkIdentifier|back/forth/next/prev/previous/this|


Referred To All Tokens Except|TokenTkcontinuedlineorwhitespace|TokenTknewline


----End:Checks--------


----Begin:Directives--------
// one reason to use FACTOR is that it can't have the term "or" (unless in parens) and so it won't interfere with answer "a" with "b" or "c", which would otherwise be parsed as answer "a" with "true" because ("b" or "c" is true)
InRulesReplaceWholeWord|FACTOR|Lvl6Expression
InRulesReplaceWholeWord|MAYBE_FACTOR|Lvl6Expression
InRulesReplaceWholeWord|MAYBE_ALLOW_ARITH|Lvl4Expression
InRulesReplaceWholeWord|ARITH|Lvl4Expression
InRulesReplaceWholeWord|TkSyntaxMarker|TkNewLine
----End:Directives--------

