
/*

SIMPLIFIED VPC GRAMMER
1) check levels, if final level is not 0 then quit w error
i.e. the grammer doesn't need to validate that on custom1 and end custom1 match
2) kill comments
3) lex
4) parse
look up fn+command names at runtime, not compile time
because user defined fns can be made

on thecustomhandler
    repeat with x = 1 to 5
        next repeat
        repeat forever
            add 2 to total
        end repeat
    end repeat
    ask "where is it" with "cool"
    answer "hello"
    answer "hello" & (6*3)
    answer "hello" & (6*sin(3))
    answer "hello" & (6*cos(3) + 5)
    answer "hello" & (6*cos(3) + 5 + myglobal)
    answer "hello" & (6*cos(3) + 5 + mycustom(123))
    answer "long string" & \
        "continued"
    myCustom 1,2,3
    myCustom 1,atan(1,2),3

end thecustomhandler

*/

const tokenVocab = vpcLexer.tokenVocab
const lex = vpcLexer.lex


class SelectParser extends Parser {
    // A config object as a constructor argument is normally not needed.
    // Our use case requires a dynamic configuration to support step3 without duplicating code.
    constructor(input, config) {
        super(input, tokenVocabulary, config)
        const $ = this

        this.optionalNewline = $.RULE("optionalNewline", () => {
            $.OPTION(() => {
                $.CONSUME(tokenVocab.newLine)        
            })
        })

        this.topScript = $.RULE("topScript", () => {
            $.SUBRULE(optionalNewline)
            $.MANY_SEP({
                SEP: tokenVocab.newLine,
                DEF: () => {
                    $.SUBRULE(topBlock)
                }
            })
            $.SUBRULE2(optionalNewline)
        })

        this.topBlock = $.RULE("topBlock", () => {
            $.SUBRULE(topHandler)
        })

        this.topHandler = $.RULE("topHandler", () => {
            $.CONSUME(tokenVocab.symOn);
            $.CONSUME(tokenVocab.otherIdentifier);
            $.CONSUME(tokenVocab.newLine);
            $.SUBRULE(insideABlock)
            $.CONSUME(tokenVocab.symEnd);
            $.CONSUME2(tokenVocab.otherIdentifier);            
        })

        this.insideABlock = $.RULE("insideABlock", () => {
            $.MANY(()=>{
                $.SUBRULE(anyBlockOrStatemnt)
                $.CONSUME(tokenVocab.newLine);
            })
        })

        this.topHandler = $.RULE("blockRepeat", () => {
            $.CONSUME(tokenVocab.symRepeat);
            $.CONSUME(tokenVocab.symWith);
            $.CONSUME(tokenVocab.otherIdentifier);
            $.CONSUME(tokenVocab.chrEq);
            $.SUBRULE(tokenVocab.expr);
            $.CONSUME(tokenVocab.symTo);
            $.SUBRULE2(tokenVocab.expr);
            $.CONSUME(tokenVocab.newLine);
            $.SUBRULE(insideABlock)
            $.CONSUME(tokenVocab.symEnd);           
            $.CONSUME(tokenVocab.symRepeat);           
        })

        this.anyBlockOrStatemnt = $.RULE("anyBlockOrStatemnt", () => {
            $.OR([
                {ALT: () => { $.SUBRULE(blockRepeat)}},
                {ALT: () => { $.SUBRULE(Statement)}},
           ]);
        })


        this.Statement = $.RULE("Statement", () => {
            $.OR([
                {ALT: () => { $.SUBRULE(builtInCmdOneArg)}},
                {ALT: () => { $.SUBRULE(builtInCmdTwoArgs)}},
                {ALT: () => { $.SUBRULE(builtInCmdThreeArgs)}},
                {ALT: () => { $.SUBRULE(builtInCmdFourArgs)}},
                {ALT: () => { $.SUBRULE(builtInCmdAsk)}},
                {ALT: () => { $.SUBRULE(builtInCmdNextRepeat)}},
                {ALT: () => { $.SUBRULE(customCmd)}},
           ]);
        })

        this.builtInCmdNextRepeat = $.RULE("builtInCmdNextRepeat", () => {
            $.CONSUME(tokenVocab.symNext)
            $.CONSUME(tokenVocab.symRepeat)
        })

        this.builtInCmdLockScreen = $.RULE("builtInCmdLockScreen", () => {
            $.CONSUME(tokenVocab.symLock)
            $.CONSUME(tokenVocab.symScreen)
        })

        this.builtInCmdUnlockScreen = $.RULE("builtInCmdUnlockScreen", () => {
            $.CONSUME(tokenVocab.symUnlock)
            $.CONSUME(tokenVocab.symScreen)
        })

        



        // very important to call this after all the rules have been defined.
        // otherwise the parser may not work correctly as it will lack information
        // derived during the self analysis phase.
        Parser.performSelfAnalysis(this)
    }
}


var doParsingDemo = {
    go:function() {
        
        //result = exports.toAst('SELECT column1 FROM FROM table2')
        //s += 'result of parsing: ' + result
        return 'abcd'
    }

}

window.doParsingDemo = doParsingDemo
