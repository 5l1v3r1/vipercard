
// there are several semi-keywords, like "transparent". You can use the term transparent with no parens like set the style to transparent,
// but also create a variable (put "abc" into transparent) with no problem. so is "transparent" a keyword or not?
// the product is very lenient -- you can even assign over functions (put "abc" into cos; answer cos && cos)
// note that if we made "transparent" et all a token, then it would be difficult to allow a variable named transparent. also, we'd have nearly 100 more tokens to deal with.
// let's use this approach:
//      certain terms are reserved keywords like "word", "item". defined as tokens, cannot be used as variable names at all.
//      certain terms are built-in properties/functions. "cos", "mouseloc". not defined as tokens. if you try 'put "abc" into cos' we check at runtime and error then.
//      certain terms are allowed as variable names and understood in some contexts. like "transparent" or "gray".
//      another benefit: user typos like "autoHilite2" don't create a mysterious syntax error, can have a better error message, "unknown property"

// Be careful when lexing because tokens are greedy. If you have 3 tokens /fro/ /from/ /frome/,
// the string "from frome" becomes [fro, m, fro, me].
// the (?![a-zA-Z0-9_]) means to look ahead to make sure no other word/letters are there.
// important, otherwise if you have tokens "the" and "then", you'd need to order everything right, or "then" would lex into "the", "n"

// I really put time into reducing the number of tokens used, for better perf when lexing.
// use the fact that Chevrotain has no special starting rule, any of the grammar rules can be invoked as the starting rule.
// so, from the line analysis stage, look at the first token and call one of the rules as appropriate. (if token[0] == 'add' call parser.StmtAdd() )
// I'm reducing the number of tokens kind of absurdly, ideally tokens with different semantics (== vs >=) should still be separate
// possible alternative; Chevrotain supports dynamic lexing kinda for this purpose, you switch between sets of tokens based on context
// I spent like 9 hours reducing the number of tokens from over 170 to under 40.
// Good parts about reducing number of tokens:
//      lexing is faster. and we lex a lot.
//      user gets better error messages. if we made all builtin functions a token and disallowed custom functions, but then sin2(x) would be a syntax error
//      if rules have a lot of options like { first | second | third | fourth }, the visitor at runtime has to loop through them to check which is not-null which isn't ideal
// Bad parts about reducing number of tokens:
//      more analysis needed at runtime. although we already need to do a lot of analysis there anyways, so it's not so bad. do need to confirm the right words use though.
//      grammar is more fragile for chevrotain warning (false positive?) about ambiguities. the first time I stripped it down, see real_vpc001.txt, got a lot of Chev. warnings saying "same prefix" in both paths. unclear if actually a problem but I don't want to increase the llk.
//      grammar might have actual true wrong parsing. consider "ask [password] <Expr>". if I made it "ask [TkIdentifier] <Expr>" to try to save a token, if the user typed "ask x-3" it would be parsed as (ask)(x)(-3) and mess up the expression.
//      potentially slower parsing because there are potentially more routes the grammar can take as more keywords are moved to generic TkIdentifiers; might do more backtracking



// changes from original product:
//      numbers can be written as 1e10 and 1e-10
//      continued lines can use either \ or logical not
//      you can't say "there is a line 1000 of cd fld 1" if that were ever possible
//      no custom menus: you can't say "<menuItem> of <menu>" or disable menuitem
//      you can say "a == b" which means "a = b"
//      you can say "a != b" which means "a <> b"
//      you can't say <window> { card | pattern | tool| scroll} window
//      operators are short-circuiting.  a() or b() will not call b() if a() is true
//      you can't say `part id 4`
//      you can't say `sixth button of this card` you have to say `button 6 of this card`
//      you can't say `sixth card` you have to say `card 6`
//      you can't say `cd btn 3 of recent card` or `cd btn 3 of back` or `cd btn 3 of forth`
//      you can't say `btn 3` you have to say either `cd btn 3` or `bg btn 3`
//      you can't say `marked card`
//      you can't say `btn 3 of card` you have to specify `btn 3 of card 4`
//      you can't refer to other stacks besides "this stack"
//      better to use "create btn" not "doMenu New Button"
//      doMenu supports only simple constructs
//      pop, push supports only simple constructs
//      select supports only selecting chunk of a field
//      sort only supports sorting text


// changes from v1:
//      put the sin of 4 into x is now supported
//      put sin of 4 into x is now supported
//      continued lines can use logical not

// potential improvements:
//      disallow 001 as a numeric literal
//      `get lines 3 of x` is parsed the same as `get line 3 of x` 


// comments first
TkComment=/--[^\n]*/|||||static GROUP = ChvLexer.SKIPPED
// whitespace is common, so add it early for better perf
// \xC2 is logical not in mac-roman
TkContinuedLineOrWhiteSpace=/(?:[ \t]+)|(?:[\\\xC2][ \t]*\n)/|||||static GROUP = ChvLexer.SKIPPED;static LINE_BREAKS = true
// a new line
TkNewLine=/\n+/|||||static LINE_BREAKS = true
// never actually lexed from user input, but used as a marker while preparing code to be parsed
TkSyntaxPlaceholder=/\?\?\?\?\?\?\?/
// needs to disallow letters coming right afterwards, otherwise 4a is valid as ["4", "a"] which isn't right.
TkNumLiteral=/[0-9]+(\.[0-9]*)?(e[-+]?[0-9]+)?(?![a-zA-Z_])/
// strings (only way to get a quote char is `put quote & "hi" & quote into s` )
TkStringLiteral=/"[^"\n]*"/
// parts
stack=OneOfWords(stack)
TkBkgndOrPluralSyn=OneOfWords(backgrounds?,bkgnds?,bgs?)
TkCardOrPluralSyn=OneOfWords(cards?,cds?)
TkBtnOrPluralSyn=OneOfWords(buttons?,btns?)
TkFldOrPluralSyn=OneOfWords(fields?,flds?)
// OneOfWords uses negative lookahead to say it is a full word
TkOfOnly=OneOfWords(of)
TkInOnly=OneOfWords(in)
TkCharOrWordOrItemOrLineOrPlural=OneOfWords(characters?,chars?,words?,items?,lines?)
TkOrdinal=OneOfWords(last,mid,middle,any,first,second,third,fourth,fifth,sixth,seventh,eighth,ninth,tenth)
TkAdjective=OneOfWords(long,short,abbreviated,abbrev,abbr)
// mult, div, power, "div", "mod"
TkMultDivideExpDivMod=OneOfOr(\* <or> \/ <or> \^ <or> div(?![a-zA-Z0-9_]) <or> mod(?![a-zA-Z0-9_]))
// not-equal, greater than, less than
// \xAD is not-equal \xB2 \xB3 are lessthan-or-equal
TkGreaterOrLessEqualOrEqual=OneOfOr(<> <or> >=? <or> <=? <or> != <or> ==? <or> \xB2 <or> \xB3 <or> \xAD)
// & means concat, && means concat with a space
TkConcatDoubleOrSingle=/&&?/
// plus or minus
TkPlusOrMinus=OneOfOr(\+ <or> -)
// simple characters
TkComma=/,/
TkLParen=/\(/
TkRParen=/\)/
// "to" needs to be a token because of chunk expression char 1 to 2
to=OneOfWords(to)
// reserved words. user cannot create a variable with these names.
the=OneOfWords(the)
or=OneOfWords(or)
there=OneOfWords(there)
is=OneOfWords(is)
not=OneOfWords(not)
and=OneOfWords(and)
contains=OneOfWords(contains)
within=OneOfWords(within)
number=OneOfWords(number)
// "id" must be a token to prevent parse errors
id=OneOfWords(id)
// must be last
TkIdentifier=/[a-zA-Z][0-9a-zA-Z_]*'/

// features for rules:
// {  a| b  } for a or b
// MANY{{
// [ optional ]


// Reorder the alternatives so that shorter common prefix lookahead paths appears after the longer ones.
// i.e. when you have a group { a | b | c } put the longer ones first. makes validation faster at least, might not make a difference at parse time.
// a bit of a space/time tradeoff in rules:
// when we cram everything into one rule, slightly less space in memory taken as CST has fewer branches
// however, this also means slightly longer time in traversing as there are many conditionals to see which subrule is not null
// another space/time tradeoff:
// separating operators into different levels to implement operator precedence: makes a bigger parse tree and more parsing code
// it's also possible to make all binary operators the same level and work out the precedence in software = smaller parse tree to hold in memory


// expressions:

// source
ExprSource:= { <FnCall> | <HSimpleContainer> | TkStringLiteral | TkNumLiteral  }               --->VpcVal--->Custom
// is {}
Lvl2Sub:= [not]  { <Lvl2TypeCheck> | <Lvl2Within> | <Lvl3Expression> }                                           --->NotReached
// is a number
Lvl2TypeCheck:= TkIdentifier { number | TkIdentifier }                                                                   --->GetChildOrImage|number[0]|TkIdentifier[1]
// is within
Lvl2Within:= {TkInOnly | within } <Lvl3Expression>                                                               --->NotReached

// placing in a tower like this is the way to fix left-recursion
// tools can't process something like <Expr:= Expr> + <Expr> because it is left-recursion
Expr:= Lvl1Expression> MANY{{ <OpLogicalOrAnd> <Lvl1Expression> }}ENDMANY                                       --->GenerateInfix|Lvl1Expression|OpLogicalOrAnd|this.evalHelp.evalOp|
Lvl1Expression:= Lvl2Expression> MANY{{ <OpEqualityGreaterLessOrContains> <Lvl2Expression> }}ENDMANY            --->GenerateInfix|Lvl2Expression|OpEqualityGreaterLessOrContains|this.evalHelp.evalOp|
Lvl2Expression:= Lvl3Expression> MANY{{ is  <Lvl2Sub>  }}ENDMANY                                                --->VpcVal--->Custom
Lvl3Expression:= Lvl4Expression> MANY{{ <OpStringConcat> <Lvl4Expression> }}ENDMANY                             --->GenerateInfix|Lvl4Expression|OpStringConcat|this.evalHelp.evalOp|
Lvl4Expression:= Lvl5Expression> MANY{{ <OpPlusMinus> <Lvl5Expression> }}ENDMANY                                --->GenerateInfix|Lvl5Expression|OpPlusMinus|this.evalHelp.evalOp|
Lvl5Expression:= Lvl6Expression> MANY{{ <OpMultDivideExpDivMod> <Lvl6Expression> }}ENDMANY                      --->GenerateInfix|Lvl6Expression|OpMultDivideExpDivMod|this.evalHelp.evalOp|
Lvl6Expression:= [ { TkPlusOrMinus | not } ] [<HChunk>] { <ExprSource> | TkLParen <Expr> TkRParen }              --->Custom
OpLogicalOrAnd:= {or | and}                                                                                      
OpEqualityGreaterLessOrContains:= { contains | TkGreaterOrLessEqualOrEqual  }                                    
OpStringConcat:= TkConcatDoubleOrSingle                                                                          --->GetChildOrImage|TkConcatDoubleOrSingle[0]
OpPlusMinus:= TkPlusOrMinus                                                                                      --->GetChildOrImage|TkPlusOrMinus[0]
OpMultDivideExpDivMod:= TkMultDivideExpDivMod                                                                    --->GetChildOrImage|TkMultDivideExpDivMod[0]
// you might see Lvl6Expression referred to as "factor".


//////////// Objects
// note use of Lvl6Expression - confirmed in product. you have to say 'cd btn (1+1)' and not 'cd btn 1+1'
// software will confirm that this is only "target" or "me" or "HyperCard"        
Object_1:=[ the ] TkIdentifier                                                                                  --->RequestedObjRef--->Custom
Object:={ <ObjectBtn> | <ObjectFld> | <ObjectCard> | <ObjectBg> | <ObjectStack> | <Object_1>  }                 
ObjectBtn:={TkCardOrPluralSyn | TkBkgndOrPluralSyn} {TkBtnOrPluralSyn id <Lvl6Expression> | TkBtnOrPluralSyn <Lvl6Expression>} [ <Of> <ObjectCard> ]                            --->RequestedObjRef--->Custom
ObjectFld:={TkCardOrPluralSyn | TkBkgndOrPluralSyn} {TkFldOrPluralSyn id <Lvl6Expression> | TkFldOrPluralSyn <Lvl6Expression>} [ <Of> <ObjectCard> ]                            --->RequestedObjRef--->Custom
ObjectCard:={ TkCardOrPluralSyn id <Lvl6Expression> | TkCardOrPluralSyn <Lvl6Expression> | <HOrdinal> TkCardOrPluralSyn | <HPosition> TkCardOrPluralSyn  } [ <Of> <ObjectBg> ]  --->RequestedObjRef--->Custom
ObjectBg:={TkBkgndOrPluralSyn id <Lvl6Expression> | TkBkgndOrPluralSyn <Lvl6Expression> | <HOrdinal> TkBkgndOrPluralSyn | <HPosition> TkBkgndOrPluralSyn } [ <Of> <ObjectStack> ]  --->RequestedObjRef--->Custom
ObjectStack:=[TkIdentifier] stack                                                                                 --->RequestedObjRef--->Custom
ObjectPart:={<ObjectBtn> | <ObjectFld> }                                                                        

///////// Properties
AnyPropertyName:= {  id | TkIdentifier  }                                                                    --->string
// we want AnyPropertyVal to take many things
// well TkIdentifier can be a Lvl1Expression (treated as variable)
// and shadow can be a Lvl1Expression (treated as variable)
// and left can be a Lvl1Expression (treated as variable)
// and center can be a Lvl1Expression (treated as variable)
// text style lists are in the form "bold, italic".
// let's be simpler and accept an arbitarary amnt of terms.
// point needs 2 terms, rect needs 4 terms, fonts need arbitrary number
AnyPropertyVal:= ATLEASTONESEP{{ TkComma / <Lvl1Expression> }}ENDATLEASTONESEP                           --->BuildMapWithAllChildren|
Of:={TkOfonly|TkInOnly}                                                                                     --->string


///////// Function calls
FnCallNumberOf:= the number TkOfOnly { <FnCallNumberOf_1> | <FnCallNumberOf_2>  | <FnCallNumberOf_3> |  <FnCallNumberOf_4>  }   --->VpcVal
FnCallNumberOf_1:= TkCharOrWordOrItemOrLineOrPlural <Of> <Lvl6Expression>                                                --->VpcVal--->Custom
FnCallNumberOf_2:= {TkCardOrPluralSyn | TkBkgndOrPluralSyn} { TkBtnOrPluralSyn | TkFldOrPluralSyn }              --->VpcVal--->Custom
FnCallNumberOf_3:= TkCardOrPluralSyn [ <Of> <ObjectBg> ] [ <Of> <ObjectStack> ]                                  --->VpcVal--->Custom
FnCallNumberOf_4:= TkBkgndOrPluralSyn [ <Of> <ObjectStack> ]                                                     --->VpcVal--->Custom

// types of calls
FnCall:= { <FnCallWithParens>  | <FnCallNumberOf> | <ExprThereIs> | <ExprGetPropertyOrOldStyleFnCall> | <ExprGetOldStyleFnCall> }   --->VpcVal
FnCallWithParens:=[the] TkIdentifier TkLParen MANYSEP{{ TkComma / <Expr> }}ENDMANYSEP  TkRParen     --->VpcVal--->Custom
// e.g. the hilite of cd btn 1 or the sin of 4
ExprGetPropertyOrOldStyleFnCall:= [the] <AnyPropertyName> TkOfOnly { <HChunk> <ObjectFld> | <Object> | <Lvl4Expression> }            --->VpcVal--->Custom
// e.g. the tickcount (this could be a global property like the itemdelim or the version)
ExprGetOldStyleFnCall:= the TkIdentifier
// e.g. there is a cd btn 1
ExprThereIs:= there is [not] TkIdentifier <Object>                                                                        --->VpcVal--->Custom



///////// Commands
// syntax rewriting will change the syntax in some of these commands, usually to turn a term into a TkSyntaxMarker
// add 4 to x
BuiltinCmdAdd:=TkIdentifier <Lvl1Expression> to <HContainer>                                                             --->BuildMapWithAllChildren|
// comfirmed in product that first argument takes any expression, but the rest have to be a Lvl6Expression (aka "factor")
// makes sense that the choices are Lvl6Expression because if they could use the term "or" (outside of parens) then answer "a" with "b" or "c", would be eval'd as answer "a" with "true"
// input was: answer {x} [with {w} [ or {y} [ or {z}]]]
// turn the 'with' into TkSyntaxMarker for easier parsing later
// safe because there can't be a real variable/function called "with".
// otherwise we'd have to make 'with' a token or make it illegal in an expression, which is inefficient
BuiltinCmdAnswer:=TkIdentifier <Expr> [TkSyntaxMarker <Lvl6Expression> [ or <Lvl6Expression> [ or <Lvl6Expression>]]]                 --->BuildMapWithAllChildren|
// ask. the TkComma refers to if this was "ask password"
BuiltinCmdAsk:=TkIdentifier [TkComma] <Expr> [TkSyntaxMarker <Expr>]                                            --->BuildMapWithAllChildren|
// wait supports  second,seconds,milliseconds,ms,ticks (tick = 1/60s)
BuiltinCmdWait:=TkIdentifier [TkSyntaxMarker] <Expr> { TkIdentifier | TkOrdinal  }                              --->BuildMapWithAllChildren|
// make beep sound
BuiltinCmdBeep:=TkIdentifier [<Expr>]                                                                           --->BuildMapWithAllChildren|
// in rewrite, we'll turn 'choose line tool' into 'choose "line" syntaxmarker' and turn 'choose tool 6' into 'choose syntaxmarker 6'
BuiltinCmdChoose:=TkIdentifier [TkSyntaxMarker] <Expr> [TkSyntaxMarker]                --->BuildMapWithAllChildren|
// processed by syntax rewriting
BuiltinCmdClick:=TkIdentifier TkIdentifier <Lvl4Expression> TkComma <Lvl4Expression> [ TkSyntaxMarker TkIdentifier [ TkComma TkIdentifier [ TkComma TkIdentifier ] ] ]  --->BuildMapWithAllChildren|
// vipercard only
BuiltinCmdCreate:=TkIdentifier TkCardOrPluralSyn { TkBtnOrPluralSyn | TkFldOrPluralSyn }                                   --->BuildMapWithAllChildren|
// delete a chunk
BuiltinCmdDelete:=TkIdentifier { <HChunk> <HSimpleContainer> | <ObjectPart> }                                   --->BuildMapWithAllChildren|
// make dial tone sounds
BuiltinCmdDial:=TkIdentifier <Expr>                                                                           --->BuildMapWithAllChildren|
// disable a button
BuiltinCmdDisable:=TkIdentifier <ObjectBtn>                                                                     --->BuildMapWithAllChildren|
// divide a number, e.g. divide x by 2
BuiltinCmdDivide:=TkIdentifier <HContainer> TkSyntaxMarker <Lvl1Expression>                                              --->BuildMapWithAllChildren|
// do "answer 2"
BuiltinCmdDo:=TkIdentifier <Expr>      --->BuildMapWithAllChildren|
// we'll provide some for compatibility
BuiltinCmdDoMenu:=TkIdentifier <Expr>      --->BuildMapWithAllChildren|
// drag, to simulate painting
BuiltinCmdDrag:=TkIdentifier TkIdentifier <Lvl4Expression> TkComma <Lvl4Expression> ATLEASTONE{{ to <Lvl4Expression> TkComma <Lvl4Expression> }}ENDATLEASTONE [ TkSyntaxMarker TkIdentifier [ TkComma TkIdentifier [ TkComma TkIdentifier ] ] ]   --->BuildMapWithAllChildren|
// enable a button
BuiltinCmdEnable:=TkIdentifier <ObjectBtn>                                                                      --->BuildMapWithAllChildren|
// evaluate an expression and put the result into the variable "it"
BuiltinCmdGet:=TkIdentifier <Expr>                                                                              --->BuildMapWithAllChildren|
// go to a card
BuiltinCmdGo:=TkIdentifier TkStringLiteral TkIdentifier [ to ] {TkStringLiteral | <NtDest> | <HOrdinal> | <HPosition> }   --->BuildMapWithAllChildren|
// hide a part
BuiltinCmdHide:=TkIdentifier { <ObjectPart> | TkIdentifier }                                                --->BuildMapWithAllChildren|
// lock screen
BuiltinCmdLock:=TkIdentifier TkIdentifier                                                                   --->BuildMapWithAllChildren|
// multiply x by 4
BuiltinCmdMultiply:=TkIdentifier <HContainer> TkSyntaxMarker <Lvl1Expression>                                        --->BuildMapWithAllChildren|
// play a sound
BuiltinCmdPlay:=TkIdentifier <Expr> [ TkIdentifier ]                              --->BuildMapWithAllChildren|
// push card 2
BuiltinCmdPush:=RewrittenInSoftware
// you can specify 'before' 'after' 'into'
// the traditional <Expr> [ TkIdentifier [ <HContainer> ]] which works for now, but breaks if an Expr can ever have 2 consecutive TkIdentifiers
// instead, add a TkSyntaxMarker during syntax rewrite
BuiltinCmdPut:=TkIdentifier <Expr> TkSyntaxMarker TkIdentifier TkSyntaxMarker [ <HContainer> ]           --->BuildMapWithAllChildren|
// replace "a" with "b" in x
BuiltinCmdReplace:=TkIdentifier <Expr> TkSyntaxMarker <Expr> TkInOnly <HSimpleContainer>          --->BuildMapWithAllChildren|
// reset paint
BuiltinCmdReset:=TkIdentifier TkIdentifier                                                                  --->BuildMapWithAllChildren|
// set the property to val
BuiltinCmdSet:=TkIdentifier [the] <AnyPropertyName> [ TkOfOnly { <HChunk> <ObjectFld> | <Object> } ] to <AnyPropertyVal>    --->BuildMapWithAllChildren|
// select line 1 of cd fld a or select text of cd fld a 
BuiltinCmdSelect:=TkIdentifier { <HChunk>  | TkIdentifier TkOfOnly  <ObjectFld>  }                                                                   --->BuildMapWithAllChildren|
// note, parsed differently, since handled as a category
BuiltinCmdSend:=TkIdentifier <Expr> to <Object>                                                         --->BuildMapWithAllChildren|
// show cd btn 3
BuiltinCmdShow:=TkIdentifier { <Show_1>  | <Show_2> | TkIdentifier }                                        --->BuildMapWithAllChildren|
// sort lines of x. "by" transformed into TkSyntaxMarker
BuiltinCmdSort:=TkIdentifier [TkIdentifier] TkCharOrWordOrItemOrLineOrPlural <Of> <HContainer>  [TkIdentifier] [ TkSyntaxMarker <Expr>] --->BuildMapWithAllChildren|
// subtract 4 from x
BuiltinCmdSubtract:=TkIdentifier <Lvl1Expression> TkSyntaxMarker <HContainer>                                         --->BuildMapWithAllChildren|
// unlock screen
BuiltinCmdUnlock:=TkIdentifier TkIdentifier [ TkIdentifier <NtVisEffect> ]                                   --->BuildMapWithAllChildren|
// visual effect dissolve
BuiltinCmdVisual:=TkIdentifier <NtVisEffect>                                                                 --->BuildMapWithAllChildren|
// we used to have a separate rule for custom handlers and custom functions, but we might as well use the same syntax though-- now they both return via setting value of "result", they do exactly the same thing
TopLevelRequestHandlerCall:=TkIdentifier TkIdentifier MANYSEP{{ TkComma / <Expr> }}ENDMANYSEP                 --->BuildMapWithAllChildren|
// just eval an expression
TopLevelRequestEval:=TkIdentifier <Expr>                                                                       --->BuildMapWithAllChildren|
///////////// Command Nonterminals
// visual effect (parse in software)
NtVisEffect:=MANY{{ TkIdentifier | to  | TkInOnly  }}ENDMANY
// go to bg 2
NtDest:={ <ObjectCard> | <ObjectBg> | <ObjectStack> }                                                           
// show cd btn 3 / show cd btn 3 at 4,5
Show_1:=<ObjectPart> [ TkSyntaxMarker <Lvl4Expression> TkComma <Lvl4Expression> ]                     --->BuildMapWithAllChildren|
// show all cards
Show_2:=[ TkIdentifier ] TkCardOrPluralSyn                                                                  --->BuildMapWithAllChildren|


// "lookahead" only comes into play when there is an OPTIONAL, OR, etc. block
// otherwise we'll greedily eat whatever comes our way.
// this issue arose when dealing with "x is y" versus "x is within y", had to make "within" a token so it wouldn't go the wrong way
// if the grammar is
// Expr1:= <Expr2> letterc Integer 
// Expr2:= letterb [letterc lettera]
// I would have hoped that "b c 123" would work, trying out Expr2 and then falling back to Expr1
// but no, once we go into Expr2 we can never fall back into Expr1.
// increasing the 'lookahead' parameter in general isn't a good solution.


/////////////////// chunks/sources
// the first / the second
HOrdinal:= [ the ] TkOrdinal                                                                                    --->string--->GetChildOrImage|TkOrdinal[0]
// this/the prev/the next
HPosition:= [ the ] TkIdentifier                                                                                --->string--->GetChildOrImage|TkIdentifier[0]
// emulator does allow setting a btn as a container, doesn't seem to do anything.
// to support "the msg box" as a container, for simplicity we handle this before parsing, in the rewrite stage, rewriting the phrase to be a single special variable name,
// and any writes to this variable are redirected.
HSimpleContainer:= { <ObjectPart> |  TkIdentifier }                                             --->RequestedContainerRef--->Custom
HContainer:= [<HChunk>] <HSimpleContainer>                                                                      --->RequestedContainerRef--->Custom
HChunk:={ TkCharOrWordOrItemOrLineOrPlural <HChunk_1> | <HOrdinal> TkCharOrWordOrItemOrLineOrPlural } <Of>      --->RequestedChunk--->Custom
HChunk_1:= <HChunkAmt> [ to <HChunkAmt> ]                                                                 --->NotReached
HChunkAmt:= { TkLParen <Expr> TkRParen | TkNumLiteral | <HSimpleContainer> }                          --->Custom

